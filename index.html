<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>F1 Card Tracker</title>
    
    <!-- PWA Meta Tags -->
    <meta name="application-name" content="F1 Card Tracker">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="F1 Tracker">
    <meta name="description" content="Track your 2025 Topps Chrome F1 card collection">
    <meta name="theme-color" content="#0f172a">
    
    <!-- App Icons -->
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">

    <!-- Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
    <style>
        html { overflow-x: hidden; }
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; overflow-x: hidden; }
        .card-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.75rem; }
        @media (min-width: 768px) {
            .card-grid { grid-template-columns: repeat(4, 1fr); }
        }
        @media (max-width: 767px) {
            .card-grid { grid-template-columns: repeat(2, 1fr); }
        }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        .analysis-text { white-space: pre-wrap; line-height: 1.6; }
        .analysis-text h3 { font-weight: bold; font-size: 1.1em; margin-top: 1em; margin-bottom: 0.5em; color: #93c5fd; }
        .analysis-text ul { list-style-type: disc; margin-left: 1.5em; margin-bottom: 0.5em; }
        .analysis-text li { margin-bottom: 0.25em; }
        .analysis-text strong { color: #60a5fa; font-weight: 600; }
        .needs-verification { background: rgba(251, 191, 36, 0.2); border: 1px solid rgba(251, 191, 36, 0.5); position: relative; }
        .tooltip { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: #1e293b; color: #fbbf24; padding: 0.5rem; rounded: 0.5rem; white-space: nowrap; font-size: 0.75rem; display: none; z-index: 1000; border: 1px solid #fbbf24; }
        .needs-verification:hover .tooltip { display: block; }
        :root {
            --page-number-top: 160px;
            --page-divider-top: 176px;
        }
        .page-number {
            position: sticky;
            left: 0;
            top: var(--page-number-top);
            z-index: 20;
            font-size: 4rem;
            font-weight: 900;
            color: #1e293b;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            line-height: 1;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
            margin-right: 1rem;
            display: none;
            user-select: none;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .page-number:hover {
            opacity: 0.7;
        }
        @media (min-width: 768px) {
            .page-number {
                display: flex;
                align-items: flex-start;
            }
        }
        .page-divider {
            position: sticky;
            top: var(--page-divider-top);
            z-index: 20;
        }
        .page-container {
            position: relative;
            padding-left: 0;
        }
        .page-menu-item {
            padding: 10px 18px;
            cursor: pointer;
            color: #94a3b8;
            text-align: left;
            font-size: 13px;
            font-weight: 500;
            border-bottom: 1px solid rgba(51, 65, 85, 0.5);
            transition: all 0.15s ease;
            letter-spacing: 0.02em;
        }
        .page-menu-item:hover {
            background: rgba(59, 130, 246, 0.15) !important;
            color: #e2e8f0 !important;
            padding-left: 22px;
        }
        .page-menu-item:last-child {
            border-bottom: none;
        }
        .page-menu-item.active {
            background: linear-gradient(135deg, #1e40af, #3b82f6) !important;
            color: #ffffff !important;
            font-weight: 700;
            border-left: 3px solid #60a5fa;
        }
        .hamburger:hover { color: #60a5fa; transition: color 0.2s; }
        .dropdown-menu { position: absolute; top: 60px; left: 16px; background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%); border: 1px solid rgba(71, 85, 105, 0.6); border-radius: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.4), 0 0 12px rgba(59,130,246,0.05); z-index: 1000; min-width: 180px; padding: 6px 0; overflow: hidden; }
        .dropdown-item { padding: 10px 18px; cursor: pointer; color: #e2e8f0; transition: all 0.15s; text-align: left; display: flex; align-items: center; gap: 10px; font-size: 0.9rem; border-radius: 6px; margin: 2px 6px; }
        .dropdown-item:hover { background: rgba(59, 130, 246, 0.15); color: #93c5fd; }
        .dropdown-spacer { height: 1px; background: linear-gradient(90deg, transparent, #475569, transparent); margin: 6px 12px; }
        .dropdown-item-delete { padding: 10px 18px; cursor: pointer; color: #fca5a5; border: 1px solid rgba(220, 38, 38, 0.4); border-radius: 8px; transition: all 0.15s; text-align: left; display: flex; align-items: center; gap: 10px; font-size: 0.9rem; margin: 8px 6px 6px 6px; }
        .dropdown-item-delete:hover { background: rgba(127, 29, 29, 0.5); color: #fecaca; border-color: #dc2626; }
        
        /* Mobile-friendly touch targets */
        @media (max-width: 767px) {
            button, a { min-height: 44px; min-width: 44px; }
            button:active, a:active { transform: scale(0.98); }
            input, select, textarea { min-height: 44px; font-size: 16px; }
        }
        
        /* Prevent zoom on input focus */
        @media (max-width: 767px) {
            input[type="text"],
            input[type="number"],
            select,
            textarea {
                font-size: 16px;
            }
        }
        
        /* Safe area inset for notch devices */
        @media (max-width: 767px) {
            .fixed { padding-left: max(0.5rem, env(safe-area-inset-left)); padding-right: max(0.5rem, env(safe-area-inset-right)); }
            .sticky { padding-left: max(0.5rem, env(safe-area-inset-left)); padding-right: max(0.5rem, env(safe-area-inset-right)); }
        }
        
        /* Smooth momentum scrolling on mobile */
        @media (max-width: 767px) {
            * { -webkit-tap-highlight-color: transparent; }
            body, html { -webkit-user-select: none; user-select: none; -webkit-touch-callout: none; }
            input, textarea, select, button { -webkit-user-select: text; user-select: text; }
            .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
            .scrollbar-hide::-webkit-scrollbar { display: none; }
            
            /* Checkered pattern badge styles */
            .checker-badge {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                width: 100%;
                height: 100%;
                border-radius: 9999px;
                font-weight: bold;
                box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1);
            }
            
            .checker-badge svg {
                width: 100%;
                height: 100%;
                border-radius: 9999px;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script src="card-database.js"></script>
    <script src="chatbot-component.js"></script>
    
    <script>
    // Authentication check
    const token = localStorage.getItem('f1-token');
    if (!token) {
      window.location.href = 'login.html';
    }
    
    const userEmail = localStorage.getItem('f1-email') || 'User';

    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const API_BASE = "https://f1-card-tracker-backend-1.onrender.com";
        const API_URL = API_BASE + "/api/recognize";
        window.API_URL = API_URL;
        const cardData = COMPLETE_CARD_DATABASE || [];

        // Helper to add auth header to all requests
        function getAuthHeaders() {
        return {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
        };
        }

        const OFFICIAL_VARIANTS = [
            // Base & Standard Refractors
            'Base',
            'Refractor',
            
            // Numbered Color Refractors
            'Teal Refractor /299',
            'Pink Refractor /250',
            'Aqua Refractor /199',
            'Blue Refractor /150',
            'Green Refractor /99',
            'F1 75th Anniversary Refractor /75',
            'Gold Refractor /50',
            'Orange Refractor /25',
            'Black Refractor /10',
            'Red Refractor /5',
            
            // Checker Flag Parallels (Hobby exclusive)
            'Checker Flag',
            'Pink Checker Flag /250',
            'Aqua Checker Flag /199',
            'Blue Checker Flag /150',
            'Green Checker Flag /99',
            'Gold Checker Flag /50',
            'Orange Checker Flag /25',
            'Black Checker Flag /10',
            'Red Checker Flag /5',
            
            // RayWave Parallels (Blaster exclusive)
            'B&W RayWave',
            'Pink RayWave /250',
            'Aqua RayWave /199',
            'Blue RayWave /150',
            'Forest Green RayWave /140',
            'Green RayWave /99',
            'Gold RayWave /50',
            'Orange RayWave /25',
            'Black RayWave /10',
            'Red RayWave /5',
            
            // Lazer (Hobby exclusive)
            'B&W Lazer',
            
            // Ultra Rare
            'SuperFractor 1/1',
            
            // Special Types
            'Logofractor',
            'Sapphire Edition',
            'Padparadscha Sapphire 1/1',
            
            // Printing Plates
            'Printing Plate Cyan 1/1',
            'Printing Plate Magenta 1/1',
            'Printing Plate Yellow 1/1',
            'Printing Plate Black 1/1'
        ];

        const variants = OFFICIAL_VARIANTS;

        // Variant groups for filter dropdowns
        const VARIANT_GROUPS = [
            { label: 'Standard', variants: ['Base', 'Refractor'] },
            { label: 'Numbered Refractors', variants: ['Teal Refractor /299', 'Pink Refractor /250', 'Aqua Refractor /199', 'Blue Refractor /150', 'Green Refractor /99', 'F1 75th Anniversary Refractor /75', 'Gold Refractor /50', 'Orange Refractor /25', 'Black Refractor /10', 'Red Refractor /5'] },
            { label: 'Checker Flag Parallels', variants: ['Checker Flag', 'Pink Checker Flag /250', 'Aqua Checker Flag /199', 'Blue Checker Flag /150', 'Green Checker Flag /99', 'Gold Checker Flag /50', 'Orange Checker Flag /25', 'Black Checker Flag /10', 'Red Checker Flag /5'] },
            { label: 'RayWave Parallels', variants: ['B&W RayWave', 'Pink RayWave /250', 'Aqua RayWave /199', 'Blue RayWave /150', 'Forest Green RayWave /140', 'Green RayWave /99', 'Gold RayWave /50', 'Orange RayWave /25', 'Black RayWave /10', 'Red RayWave /5'] },
            { label: 'Lazer & Special', variants: ['B&W Lazer', 'SuperFractor 1/1', 'Logofractor', 'Sapphire Edition', 'Padparadscha Sapphire 1/1'] },
            { label: 'Printing Plates', variants: ['Printing Plate Cyan 1/1', 'Printing Plate Magenta 1/1', 'Printing Plate Yellow 1/1', 'Printing Plate Black 1/1'] }
        ];

        // Helper function to format Quick Grade Report with app-matching style and responsive design
        const formatQuickGradeReport = (gradeText) => {
            if (!gradeText) {
                return <div className="text-slate-400">No assessment available</div>;
            }
            
            // Define all possible section headers
            const sectionHeaders = [
                'FINAL ASSESSMENT',
                'GRADE PROBABILITY',
                'CONDITION CHECKLIST',
                'DETAILED ANALYSIS',
                'NOTES',
                'GRADE PROBABILITY ESTIMATE',
                'SUMMARY ASSESSMENT',
                'VISUAL CHECKLIST',
                'DETAILED FINDINGS'
            ];
            
            const sections = {};
            let currentSection = '';
            const lines = gradeText.split('\n');
            
            // Parse sections - capture ALL content
            lines.forEach((line, idx) => {
                const upperLine = line.toUpperCase().trim();
                
                // Check if this line is a section header
                let foundHeader = false;
                for (let header of sectionHeaders) {
                    if (upperLine.startsWith(header)) {
                        currentSection = header;
                        sections[currentSection] = [];
                        foundHeader = true;
                        break;
                    }
                }
                
                if (!foundHeader && currentSection && line.trim()) {
                    // Skip separator lines and clean up symbols
                    if (line.trim() !== '===================================================' && 
                        line.trim() !== '---' && 
                        line.trim() !== '====' &&
                        !line.trim().startsWith('=')) {
                        // Clean line by removing # and * symbols at start
                        let cleanLine = line.trim().replace(/^[#*\s]+/, '');
                        if (cleanLine) {
                            sections[currentSection].push(cleanLine);
                        }
                    }
                }
            });
            
            // Fallback: if no sections found, treat entire text as content
            if (Object.keys(sections).length === 0) {
                return (
                    <div className="text-sm space-y-2 text-slate-300 break-words leading-relaxed">
                        {lines.filter(l => l.trim()).map((line, idx) => {
                            // Clean symbols from fallback lines too
                            const cleanLine = line.trim().replace(/^[#*\s]+/, '');
                            return cleanLine ? <div key={idx}>{cleanLine}</div> : null;
                        }).filter(Boolean)}
                    </div>
                );
            }
            
            // Reorder sections: FINAL ASSESSMENT first, then others in priority
            const prioritySections = ['FINAL ASSESSMENT', 'GRADE PROBABILITY', 'CONDITION CHECKLIST', 'DETAILED ANALYSIS', 'NOTES'];
            const orderedSections = [];
            
            // Add priority sections first in order
            prioritySections.forEach(key => {
                if (sections[key] && sections[key].length > 0) {
                    orderedSections.push({ key, content: sections[key] });
                    delete sections[key];
                }
            });
            
            // Add remaining sections
            Object.keys(sections).forEach(key => {
                if (sections[key] && sections[key].length > 0) {
                    orderedSections.push({ key, content: sections[key] });
                }
            });
            
            // Helper function to extract and left-align emojis
            const formatLineWithEmojis = (line) => {
                // Extract emojis from start of line
                const emojiMatch = line.match(/^([\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F1E0}-\u{1F1FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]+)/u);
                if (emojiMatch) {
                    const emoji = emojiMatch[1];
                    const restOfLine = line.substring(emoji.length).trim();
                    return { emoji, text: restOfLine };
                }
                return { emoji: null, text: line };
            };
            
            // Format as JSX with improved styling
            return (
                <div className="space-y-4 text-slate-300 text-sm">
                    {orderedSections.map((section, idx) => (
                        <div key={idx} className="space-y-2">
                            {/* Section header - clean and modern */}
                            <div className="text-sm font-semibold text-blue-400 border-l-2 border-blue-400 pl-2 bg-blue-950/30 py-1 rounded-r">
                                {section.key}
                            </div>
                            
                            {/* Section content with improved formatting */}
                            <div className="space-y-1.5 ml-2">
                                {section.content.length === 0 ? (
                                    <div className="text-slate-500 italic text-xs">No content</div>
                                ) : (
                                    section.content.map((line, lineIdx) => {
                                        // Format line with emoji separation
                                        const { emoji, text } = formatLineWithEmojis(line);
                                        
                                        // Handle checklist items: "Centering: PASS/FAIL"
                                        const checklistMatch = text.match(/^([A-Za-z\s\/&]+?):\s*(PASS|FAIL|Yes|No)/i);
                                        if (checklistMatch) {
                                            const checkItem = checklistMatch[1].trim();
                                            const status = checklistMatch[2].toUpperCase();
                                            const isPass = status === 'PASS' || status === 'YES';
                                            const remainingText = text.substring(text.indexOf(':') + 1).trim();
                                            
                                            return (
                                                <div key={lineIdx} className="flex items-start gap-2 text-sm">
                                                    {emoji && <span className="flex-shrink-0">{emoji}</span>}
                                                    <div className="flex gap-2 items-baseline flex-wrap flex-1">
                                                        <span className="font-semibold text-slate-300 flex-shrink-0">{checkItem}:</span>
                                                        <span className={`font-semibold flex-shrink-0 ${isPass ? 'text-green-400' : 'text-red-400'}`}>
                                                            {status}
                                                        </span>
                                                        {remainingText && remainingText !== status && (
                                                            <span className="text-slate-400 flex-grow">{remainingText.replace(status, '').trim()}</span>
                                                        )}
                                                    </div>
                                                </div>
                                            );
                                        }
                                        
                                        // Handle PSA percentage lines: "PSA 10: 85%"
                                        const psaMatch = text.match(/^PSA\s+(\d+):\s*([\d.]+%)/i);
                                        if (psaMatch) {
                                            const grade = psaMatch[1];
                                            const percentage = psaMatch[2];
                                            const remainingText = text.substring(text.indexOf(':') + 1).trim();
                                            
                                            return (
                                                <div key={lineIdx} className="flex items-start gap-2 text-sm">
                                                    {emoji && <span className="flex-shrink-0">{emoji}</span>}
                                                    <div className="flex gap-2 items-baseline flex-wrap flex-1">
                                                        <span className="font-semibold text-slate-300 flex-shrink-0">PSA {grade}:</span>
                                                        <span className="text-yellow-300 font-semibold flex-shrink-0">{percentage}</span>
                                                        {remainingText && remainingText !== percentage && (
                                                            <span className="text-slate-400 flex-grow">{remainingText.replace(percentage, '').trim()}</span>
                                                        )}
                                                    </div>
                                                </div>
                                            );
                                        }
                                        
                                        // Handle "Estimated PSA Grade: X with Y% confidence"
                                        if (text.toLowerCase().includes('estimated psa grade') || 
                                            text.toLowerCase().includes('recommended for grading')) {
                                            const colonIdx = text.indexOf(':');
                                            if (colonIdx > -1) {
                                                const label = text.substring(0, colonIdx).trim();
                                                const value = text.substring(colonIdx + 1).trim();
                                                return (
                                                    <div key={lineIdx} className="flex items-start gap-2 text-sm">
                                                        {emoji && <span className="flex-shrink-0">{emoji}</span>}
                                                        <div className="flex gap-2 items-baseline flex-wrap flex-1">
                                                            <span className="font-semibold text-slate-300">{label}:</span>
                                                            <span className="text-blue-300 font-semibold">{value}</span>
                                                        </div>
                                                    </div>
                                                );
                                            }
                                        }
                                        
                                        // Handle key-value pairs with colons
                                        const kvMatch = text.match(/^([^:]+?):\s*(.+)$/);
                                        if (kvMatch) {
                                            const label = kvMatch[1].trim();
                                            const value = kvMatch[2].trim();
                                            
                                            return (
                                                <div key={lineIdx} className="flex items-start gap-2 text-sm">
                                                    {emoji && <span className="flex-shrink-0">{emoji}</span>}
                                                    <div className="space-y-0.5 flex-1">
                                                        <div className="font-semibold text-slate-300">{label}</div>
                                                        <div className="text-slate-400 ml-2 leading-relaxed break-words">{value}</div>
                                                    </div>
                                                </div>
                                            );
                                        }
                                        
                                        // Handle bracketed text [...]
                                        if (text.startsWith('[') && text.endsWith(']')) {
                                            const content = text.slice(1, -1).trim();
                                            return (
                                                <div key={lineIdx} className="flex items-start gap-2 text-sm">
                                                    {emoji && <span className="flex-shrink-0">{emoji}</span>}
                                                    <div className="text-slate-400 italic break-words flex-1">
                                                        {content}
                                                    </div>
                                                </div>
                                            );
                                        }
                                        
                                        // Regular text lines with emoji separation
                                        return (
                                            <div key={lineIdx} className="flex items-start gap-2 text-sm">
                                                {emoji && <span className="flex-shrink-0">{emoji}</span>}
                                                <div className="text-slate-300 leading-relaxed break-words flex-1">
                                                    {text}
                                                </div>
                                            </div>
                                        );
                                    })
                                )}
                            </div>
                        </div>
                    ))}
                </div>
            );
        };
        // Format AI analysis text (value analysis) with clean rendering
        const formatAnalysisText = (text) => {
            if (!text) return null;

            // Normalize escaped newlines
            const normalized = text.replace(/\\n/g, '\n');
            const lines = normalized.split('\n');
            const elements = [];

            lines.forEach((line, idx) => {
                const trimmed = line.trim();
                if (!trimmed) return;

                // Skip pure separator lines (---, ===, etc.)
                if (/^[-=_*]{3,}$/.test(trimmed)) return;

                // Detect if original line was a markdown header before cleaning
                const isMarkdownHeader = /^#+\s+/.test(trimmed);

                // Clean markdown formatting
                let cleaned = trimmed
                    .replace(/^#+\s*/, '')           // Remove ## headers
                    .replace(/\*\*([^*]+)\*\*/g, '$1') // Remove **bold** markers
                    .replace(/^\*\s+/, '')            // Remove * bullets
                    .replace(/^-\s+/, '')             // Remove - bullets
                    .replace(/^â€¢\s*/, '')             // Remove bullet chars
                    .replace(/^\d+\.\s+/, '')         // Remove numbered list markers
                    .trim();

                if (!cleaned) return;

                // Section headers: ALL CAPS words (with optional colon and parenthetical notes)
                const isAllCapsHeader = /^[A-Z][A-Z\s&/,]{3,}(\([^)]*\))?:?\s*$/.test(cleaned) && cleaned.length < 80;
                // Also match known section headers that may be mixed case (from Opus responses)
                const knownSections = ['CARD IDENTIFICATION', 'VARIANT & RARITY', 'VALUE ESTIMATES', 'VALUE SOURCES & DERIVATION', 'VALUE SOURCES', 'COLLECTIBILITY', 'WEB SEARCH FINDINGS', 'MARKET ANALYSIS', 'INVESTMENT POTENTIAL', 'COMPARABLE SALES', 'RECENT SALES', 'SOURCES', 'MARKET TRENDS', 'RARITY', 'TOP COMPARABLE SALES'];
                const cleanedUpper = cleaned.replace(/:$/, '').replace(/\s*\([^)]*\)\s*$/, '').trim();
                const isKnownSection = knownSections.includes(cleanedUpper.toUpperCase());
                // Match markdown headers that were ## style
                const isMixedCaseHeader = isMarkdownHeader && cleaned.length < 80;

                if (isAllCapsHeader || isKnownSection || isMixedCaseHeader) {
                    elements.push(
                        <div key={idx} className="text-xs font-semibold text-blue-400 border-l-2 border-blue-400 pl-2 bg-blue-950/30 py-0.5 rounded-r mt-2 first:mt-0">
                            {cleaned.replace(/:$/, '')}
                        </div>
                    );
                    return;
                }

                // Value lines: Raw: $X-Y, PSA 9: $X-Y, PSA 10: $X-Y
                // Handle hyphen, en-dash, em-dash, and optional $ before second number
                const valueMatch = cleaned.match(/^(Raw|PSA\s*\d+)[:\s]+(\$?[\d,]+\s*[-â€“â€”]\s*\$?[\d,]+)/i);
                if (valueMatch) {
                    const label = valueMatch[1];
                    // Normalize en-dash/em-dash to hyphen and ensure leading $
                    const rawVal = valueMatch[2].replace(/[â€“â€”]/g, '-').trim();
                    const value = rawVal.startsWith('$') ? rawVal : '$' + rawVal;
                    const rest = cleaned.substring(cleaned.indexOf(valueMatch[2]) + valueMatch[2].length).replace(/^[,\s]+/, '').trim();
                    const colorClass = label.toLowerCase().includes('10') ? 'text-yellow-400' :
                                       label.toLowerCase().includes('9') ? 'text-blue-400' : 'text-green-400';
                    elements.push(
                        <div key={idx} className="flex items-baseline gap-2 text-xs ml-2">
                            <span className="text-slate-400 font-medium">{label}:</span>
                            <span className={`font-bold ${colorClass}`}>{value}</span>
                            {rest && <span className="text-slate-500 text-xs">{rest}</span>}
                        </div>
                    );
                    return;
                }

                // Comparable sale lines: "1. #XXX variant - $Y on date (source)" or "#XXX variant - $Y on date (source)"
                const saleMatch = cleaned.match(/^(?:\d+\.\s*)?#(\d+)\s+(.+?)\s*[-â€“â€”]\s*\$?([\d,]+(?:\.\d{2})?)\s+on\s+(.+?)\s*\(([^)]+)\)\s*$/i);
                if (saleMatch) {
                    elements.push(
                        <div key={idx} className="text-xs ml-3 flex items-start gap-1.5 py-0.5">
                            <span className="text-amber-400 mt-0.5">ðŸ’²</span>
                            <span>
                                <span className="text-blue-300 font-medium">#{saleMatch[1]} {saleMatch[2]}</span>
                                <span className="text-green-400 font-bold"> ${saleMatch[3]}</span>
                                <span className="text-slate-400"> on {saleMatch[4]}</span>
                                <span className="text-emerald-400/70 text-xs"> ({saleMatch[5]})</span>
                            </span>
                        </div>
                    );
                    return;
                }

                // Source/citation lines (eBay, PSA, TCGPlayer, etc.)
                const sourceMatch = cleaned.match(/^(eBay|PSA\s*(?:Price\s*Guide|Guide)?|TCGPlayer|COMC|Beckett|130point|StockX)[:\s]+(.+)$/i);
                if (sourceMatch) {
                    elements.push(
                        <div key={idx} className="text-xs ml-3 flex items-start gap-1.5">
                            <span className="text-emerald-400 mt-0.5">&#x2022;</span>
                            <span>
                                <span className="text-emerald-400 font-medium">{sourceMatch[1]}:</span>{' '}
                                <span className="text-slate-300">{sourceMatch[2]}</span>
                            </span>
                        </div>
                    );
                    return;
                }

                // Key-value pairs (Label: value)
                const kvMatch = cleaned.match(/^([^:]{2,35}):\s+(.+)$/);
                if (kvMatch && !/^https?:/.test(cleaned)) {
                    elements.push(
                        <div key={idx} className="text-xs ml-2">
                            <span className="text-slate-400 font-medium">{kvMatch[1]}:</span>{' '}
                            <span className="text-slate-300">{kvMatch[2]}</span>
                        </div>
                    );
                    return;
                }

                // Regular text
                elements.push(
                    <div key={idx} className="text-xs text-slate-300 ml-2 leading-relaxed">
                        {cleaned}
                    </div>
                );
            });

            return <div className="space-y-1">{elements}</div>;
        };

        const renderCheckerBadge = (style, text) => {
            const color1 = style.color1 || '#475569';
            const color2 = style.color2 || '#1e293b';
            const patternId = `cross-hatch-${text}`;
            
            return (
                <svg className="checker-badge" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        {/* Cross-hatch pattern with diagonal lines */}
                        <pattern id={patternId} x="0" y="0" width="8" height="8" patternUnits="userSpaceOnUse">
                            {/* Background color */}
                            <rect width="8" height="8" fill={color1} />
                            {/* Diagonal lines for cross-hatch effect */}
                            <line x1="0" y1="0" x2="8" y2="8" stroke={color2} strokeWidth="2" />
                            <line x1="8" y1="0" x2="0" y2="8" stroke={color2} strokeWidth="2" />
                        </pattern>
                    </defs>
                    {/* Background with pattern */}
                    <rect width="100" height="100" fill={`url(#${patternId})`} />
                    {/* Text overlay */}
                    <text x="50" y="55" textAnchor="middle" dominantBaseline="middle" 
                        fontSize="28" fontWeight="bold" fill="white" 
                        style={{ textShadow: '0 2px 4px rgba(0,0,0,0.5)', stroke: 'rgba(0,0,0,0.3)', strokeWidth: '0.5' }}>
                        {text}
                    </text>
                </svg>
            );
        };
        const inferVariantFromSerial = (serialNumber) => {
            if (!serialNumber) return null;
            
            // Extract just the number from formats like "/140" or "140"
            const match = serialNumber.toString().match(/(\d+)/);
            if (!match) return null;
            const serialNum = match[1];
            
            // Map serial numbers to possible variants (in order of preference for ambiguous cases)
            const serialVariantMap = {
                '299': ['Teal Refractor /299'],
                '250': ['Pink RayWave /250', 'Pink Refractor /250', 'Pink Checker Flag /250'],
                '199': ['Aqua RayWave /199', 'Aqua Refractor /199', 'Aqua Checker Flag /199'],
                '150': ['Blue RayWave /150', 'Blue Refractor /150', 'Blue Checker Flag /150'],
                '140': ['Forest Green RayWave /140'],  // Unique to this serial!
                '99': ['Green RayWave /99', 'Green Refractor /99', 'Green Checker Flag /99'],
                '75': ['F1 75th Anniversary Refractor /75'],
                '50': ['Gold RayWave /50', 'Gold Refractor /50', 'Gold Checker Flag /50'],
                '25': ['Orange RayWave /25', 'Orange Refractor /25', 'Orange Checker Flag /25'],
                '10': ['Black RayWave /10', 'Black Refractor /10', 'Black Checker Flag /10'],
                '5': ['Red RayWave /5', 'Red Refractor /5', 'Red Checker Flag /5']
            };
            
            return serialVariantMap[serialNum] || null;
        };

        // Helper function to validate or correct variant based on serial number
        const validateVariantWithSerial = (extractedVariant, serialNumber) => {
            const possibleVariants = inferVariantFromSerial(serialNumber);
            
            if (!possibleVariants) return extractedVariant; // No mapping available
            
            // If extracted variant is in the list of valid variants for this serial, use it
            if (possibleVariants.includes(extractedVariant)) {
                return extractedVariant;
            }
            
            // Otherwise, use the first (most probable) variant for this serial
            return possibleVariants[0];
        };

        const allSubsets = [...new Set(cardData.map(c => c.subset))].sort();
        const allCardNumbers = cardData.map(c => c.num);

        // Variant color/label mapping
        const variantStyles = {
            "Base": { bg: "bg-slate-500", text: "B", color: "#64748b" },
            "Refractor": { bg: "bg-gradient-to-r from-purple-400 to-pink-400", text: "R", color: "linear-gradient(to right, #c084fc, #f0abfc)" },
            "Purple Refractor /299": { bg: "bg-purple-500", text: "PU", color: "#a855f7" },
            "Blue Refractor /150": { bg: "bg-blue-500", text: "BL", color: "#3b82f6" },
            "Green Refractor /99": { bg: "bg-green-500", text: "GR", color: "#22c55e" },
            "Gold Refractor /50": { bg: "bg-yellow-500", text: "GO", color: "#eab308" },
            "Orange Refractor /25": { bg: "bg-orange-500", text: "OR", color: "#f97316" },
            "Red Refractor /5": { bg: "bg-red-500", text: "RD", color: "#ef4444" },
            "SuperFractor 1/1": { bg: "bg-gradient-to-r from-yellow-400 via-pink-500 to-purple-500", text: "SF", color: "#ec4899" },
            "Printing Plate 1/1": { bg: "bg-slate-700", text: "PP", color: "#334155" },
            "Black Refractor /10": { bg: "bg-black", text: "BK", color: "#000000" },
            "Magenta/Pink Refractor /250": { bg: "bg-pink-500", text: "PK", color: "#ec4899" },
            "Gold Wave /75": { bg: "bg-yellow-600", text: "GW", color: "#ca8a04" },
            
            // Checker Flag variants with cross-hatch patterns
            "Checker Flag": { bg: "bg-gradient-to-br from-slate-600 to-slate-800", text: "CF", svg: true, color1: "#475569", color2: "#1e293b" },
            "Pink Checker Flag /250": { bg: "bg-gradient-to-br from-pink-600 to-pink-800", text: "PC", svg: true, color1: "#ec4899", color2: "#831843" },
            "Aqua Checker Flag /199": { bg: "bg-gradient-to-br from-cyan-600 to-cyan-800", text: "AC", svg: true, color1: "#06b6d4", color2: "#164e63" },
            "Blue Checker Flag /150": { bg: "bg-gradient-to-br from-blue-600 to-blue-800", text: "BC", svg: true, color1: "#2563eb", color2: "#1e3a8a" },
            "Green Checker Flag /99": { bg: "bg-gradient-to-br from-green-600 to-green-800", text: "GC", svg: true, color1: "#16a34a", color2: "#15803d" },
            "Gold Checker Flag /50": { bg: "bg-gradient-to-br from-yellow-600 to-yellow-800", text: "GD", svg: true, color1: "#ca8a04", color2: "#713f12" },
            "Orange Checker Flag /25": { bg: "bg-gradient-to-br from-orange-600 to-orange-800", text: "OC", svg: true, color1: "#ea580c", color2: "#7c2d12" },
            "Black Checker Flag /10": { bg: "bg-gradient-to-br from-gray-700 to-gray-900", text: "BK", svg: true, color1: "#374151", color2: "#111827" },
            "Red Checker Flag /5": { bg: "bg-gradient-to-br from-red-600 to-red-800", text: "RC", svg: true, color1: "#dc2626", color2: "#7f1d1d" },
            
            // Teal and other numbered refractors
            "Teal Refractor /299": { bg: "bg-teal-500", text: "TE", color: "#14b8a6" },
            "Pink Refractor /250": { bg: "bg-pink-500", text: "PK", color: "#ec4899" },
            "Aqua Refractor /199": { bg: "bg-cyan-500", text: "AQ", color: "#06b6d4" },
            
            // Lazer
            "B&W Lazer": { bg: "bg-gradient-to-r from-white to-gray-800", text: "LZ", color: "#ffffff" },
            
            // RayWave
            "B&W RayWave": { bg: "bg-gradient-to-r from-gray-400 to-gray-800", text: "RW", color: "#9ca3af" },
            "Pink RayWave /250": { bg: "bg-pink-600", text: "RW", color: "#be185d" },
            "Aqua RayWave /199": { bg: "bg-cyan-600", text: "RW", color: "#0891b2" },
            "Blue RayWave /150": { bg: "bg-blue-600", text: "RW", color: "#1d4ed8" },
            "Forest Green RayWave /140": { bg: "bg-emerald-700", text: "RW", color: "#046857" },
            "Green RayWave /99": { bg: "bg-green-600", text: "RW", color: "#15803d" },
            "Gold RayWave /50": { bg: "bg-yellow-600", text: "RW", color: "#ca8a04" },
            "Orange RayWave /25": { bg: "bg-orange-600", text: "RW", color: "#9a3412" },
            "Black RayWave /10": { bg: "bg-black", text: "RW", color: "#000000" },
            "Red RayWave /5": { bg: "bg-red-600", text: "RW", color: "#991b1b" },
            
            // Special editions
            "F1 75th Anniversary Refractor /75": { bg: "bg-gradient-to-r from-gold-400 to-purple-500", text: "F1", color: "#fbbf24" },
            "Logofractor": { bg: "bg-gradient-to-r from-blue-500 to-cyan-500", text: "LF", color: "#06b6d4" },
            "Sapphire Edition": { bg: "bg-blue-600", text: "SA", color: "#1d4ed8" },
            "Padparadscha Sapphire 1/1": { bg: "bg-gradient-to-r from-orange-400 to-pink-400", text: "PS", color: "#fb7185" },
            
            // Printing plates
            "Printing Plate Cyan 1/1": { bg: "bg-cyan-500", text: "C", color: "#06b6d4" },
            "Printing Plate Magenta 1/1": { bg: "bg-fuchsia-500", text: "M", color: "#d946ef" },
            "Printing Plate Yellow 1/1": { bg: "bg-yellow-400", text: "Y", color: "#facc15" },
            "Printing Plate Black 1/1": { bg: "bg-slate-900", text: "K", color: "#0f172a" }
        };

        function GradeCameraModal({ cardNum, variant, autoOpen, onAutoOpenChange, onGrade, onClose, isMobile }) {
            const videoRef = React.useRef(null);
            const gradeFileRef = React.useRef(null);
            const [cameraActive, setCameraActive] = React.useState(false);
            const [cameraStream, setCameraStream] = React.useState(null);
            const [capturedImages, setCapturedImages] = React.useState([]);
            const [isGrading, setIsGrading] = React.useState(false);

            const startCamera = async () => {
                try {
                    const preferredCamera = localStorage.getItem('f1-preferred-camera');
                    const constraints = preferredCamera
                        ? { video: { deviceId: { exact: preferredCamera }, width: { ideal: 1920 }, height: { ideal: 1080 } } }
                        : { video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } } };
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    setCameraStream(stream);
                    setCameraActive(true);
                } catch (err) {
                    // If preferred camera failed, try default
                    if (localStorage.getItem('f1-preferred-camera')) {
                        try {
                            const stream = await navigator.mediaDevices.getUserMedia({
                                video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } }
                            });
                            setCameraStream(stream);
                            setCameraActive(true);
                            localStorage.removeItem('f1-preferred-camera');
                            return;
                        } catch (fallbackErr) {
                            console.error('Fallback camera also failed:', fallbackErr);
                        }
                    }
                    console.error('Camera access error:', err);
                    alert('Could not access camera. Please use file upload instead.');
                }
            };

            const stopCamera = React.useCallback(() => {
                if (cameraStream) {
                    cameraStream.getTracks().forEach(t => t.stop());
                    setCameraStream(null);
                }
                setCameraActive(false);
            }, [cameraStream]);

            const capturePhoto = () => {
                if (!videoRef.current) return;
                const canvas = document.createElement('canvas');
                canvas.width = videoRef.current.videoWidth;
                canvas.height = videoRef.current.videoHeight;
                canvas.getContext('2d').drawImage(videoRef.current, 0, 0);
                const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
                setCapturedImages(prev => [...prev, dataUrl]);
            };

            const handleFileSelect = (e) => {
                Array.from(e.target.files).forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (ev) => setCapturedImages(prev => [...prev, ev.target.result]);
                    reader.readAsDataURL(file);
                });
            };

            const handleClose = () => {
                stopCamera();
                onClose();
            };

            const submitGrade = async () => {
                if (capturedImages.length === 0) {
                    alert('Please capture or upload at least one image.');
                    return;
                }
                setIsGrading(true);
                stopCamera();
                try {
                    await onGrade(cardNum, variant, capturedImages);
                } finally {
                    setIsGrading(false);
                    onClose();
                }
            };

            // Auto-start camera on mount if toggle is on
            React.useEffect(() => {
                if (autoOpen) startCamera();
                return () => {
                    // cleanup on unmount
                };
            }, []);

            // Cleanup camera stream on unmount
            React.useEffect(() => {
                return () => {
                    if (cameraStream) cameraStream.getTracks().forEach(t => t.stop());
                };
            }, [cameraStream]);

            // Attach stream to video element
            React.useEffect(() => {
                if (videoRef.current && cameraStream) {
                    videoRef.current.srcObject = cameraStream;
                }
            }, [cameraStream]);

            return (
                <div className="fixed inset-0 bg-black/85 flex items-center justify-center p-4 z-50">
                    <div className={`bg-slate-800 rounded-2xl ${isMobile ? 'w-full max-h-[90vh] overflow-y-auto' : 'max-w-lg w-full'}`}>
                        <div className="p-4 border-b border-slate-700 flex items-center justify-between">
                            <h3 className="text-lg font-bold">
                                ðŸ“Š Grade #{cardNum} â€” {variant}
                            </h3>
                            <button onClick={handleClose} className="text-slate-400 hover:text-white text-xl leading-none">âœ•</button>
                        </div>
                        <div className="p-4 space-y-4">
                            {/* Camera auto-open toggle */}
                            <div className="flex items-center justify-between bg-slate-700/50 rounded-lg px-4 py-2">
                                <span className="text-sm text-slate-300">Auto-open camera</span>
                                <button
                                    onClick={() => onAutoOpenChange(!autoOpen)}
                                    className={`relative w-11 h-6 rounded-full transition-colors ${autoOpen ? 'bg-blue-600' : 'bg-slate-600'}`}
                                >
                                    <span className={`absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full transition-transform shadow ${autoOpen ? 'translate-x-5' : ''}`}></span>
                                </button>
                            </div>

                            {/* Camera view */}
                            {cameraActive && (
                                <div className="relative rounded-lg overflow-hidden bg-black">
                                    <video ref={videoRef} autoPlay playsInline muted className="w-full" style={{ maxHeight: '300px', objectFit: 'contain' }} />
                                    <div className="absolute bottom-3 left-0 right-0 flex justify-center">
                                        <button
                                            onClick={capturePhoto}
                                            className="w-14 h-14 bg-white rounded-full border-4 border-slate-300 shadow-lg hover:scale-105 transition-transform flex items-center justify-center"
                                        >
                                            <div className="w-10 h-10 bg-red-500 rounded-full"></div>
                                        </button>
                                    </div>
                                </div>
                            )}

                            {/* Action buttons */}
                            <div className="flex gap-2">
                                {!cameraActive ? (
                                    <button onClick={startCamera} className="flex-1 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-semibold">
                                        ðŸ“· Open Camera
                                    </button>
                                ) : (
                                    <button onClick={stopCamera} className="flex-1 py-2 bg-slate-600 hover:bg-slate-500 rounded-lg text-sm font-semibold">
                                        Stop Camera
                                    </button>
                                )}
                                <button onClick={() => gradeFileRef.current?.click()} className="flex-1 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm font-semibold border border-slate-500">
                                    ðŸ“ Choose File
                                </button>
                                <input ref={gradeFileRef} type="file" accept="image/*" multiple onChange={handleFileSelect} className="hidden" />
                            </div>

                            {/* Captured images preview */}
                            {capturedImages.length > 0 && (
                                <div>
                                    <div className="text-xs text-slate-400 mb-2">{capturedImages.length} image{capturedImages.length > 1 ? 's' : ''} ready</div>
                                    <div className="flex gap-2 overflow-x-auto pb-2">
                                        {capturedImages.map((img, idx) => (
                                            <div key={idx} className="relative flex-shrink-0">
                                                <img src={img} className="h-20 w-20 object-cover rounded-lg border border-slate-600" />
                                                <button
                                                    onClick={() => setCapturedImages(prev => prev.filter((_, i) => i !== idx))}
                                                    className="absolute -top-1 -right-1 w-5 h-5 bg-red-600 rounded-full text-xs flex items-center justify-center"
                                                >âœ•</button>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {/* Submit */}
                            <button
                                onClick={submitGrade}
                                disabled={capturedImages.length === 0 || isGrading}
                                className="w-full py-3 bg-amber-600 hover:bg-amber-700 disabled:opacity-50 disabled:cursor-not-allowed rounded-lg font-bold text-sm transition-colors"
                            >
                                {isGrading ? 'âŸ³ Grading...' : `ðŸ“Š Grade Card (${capturedImages.length} image${capturedImages.length !== 1 ? 's' : ''})`}
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        function App() {
            const [collection, setCollection] = useState({});
            const [selectedCard, setSelectedCard] = useState(null);
            const [searchTerm, setSearchTerm] = useState("");
            const [filterSubset, setFilterSubset] = useState("all");
            const [filterRookie, setFilterRookie] = useState("all");
            const [filterVariants, setFilterVariants] = useState([]); // Multi-select variant filter
            const [filterValues, setFilterValues] = useState([]); // Multi-select value filter
            const [ownedFilter, setOwnedFilter] = useState('all');  // 'all', 'owned', or 'not_owned'
            const [showImageUpload, setShowImageUpload] = useState(false);
            const [showMenuDropdown, setShowMenuDropdown] = useState(false);
            const [showFiltersDropdown, setShowFiltersDropdown] = useState(false);  // Mobile filters dropdown
            const [uploadedImages, setUploadedImages] = useState([]);
            const [pendingImages, setPendingImages] = useState([]);  // Images waiting for confirmation
            const [showSecondImagePrompt, setShowSecondImagePrompt] = useState(false);  // Show prompt for second image
            const [recognizedCard, setRecognizedCard] = useState(null);
            const [isRecognizing, setIsRecognizing] = useState(false);
            const [recognitionError, setRecognitionError] = useState(null);
            const [serverOnline, setServerOnline] = useState(false);
            const [isEditing, setIsEditing] = useState(false);
            const [editedCard, setEditedCard] = useState(null);
            const [showResetConfirm, setShowResetConfirm] = useState(false);
            const [showExportBeforeDelete, setShowExportBeforeDelete] = useState(false);
            const [analyzingCards, setAnalyzingCards] = useState({});
            const [bulkAnalyzing, setBulkAnalyzing] = useState(false);
            const [bulkAnalyzeProgress, setBulkAnalyzeProgress] = useState({ current: 0, total: 0 });
            const [bulkSelectMode, setBulkSelectMode] = useState(false);
            const [bulkSelectedCards, setBulkSelectedCards] = useState(new Set());
            const [deepAnalysis, setDeepAnalysis] = useState(null);
            const [isDeepAnalyzing, setIsDeepAnalyzing] = useState(false);
            const [selectedAnalysisSource, setSelectedAnalysisSource] = useState('opus'); // 'sonnet' or 'opus'
            const [showImageViewer, setShowImageViewer] = useState(false);
            const [imageViewerZoom, setImageViewerZoom] = useState(1);
            const [imageViewerPosition, setImageViewerPosition] = useState({ x: 0, y: 0 });
            const [currentImageIndex, setCurrentImageIndex] = useState(0);  // Track current image being viewed
            const [imageViewerTouchStart, setImageViewerTouchStart] = useState({ x: 0, y: 0, distance: 0 });  // Track touch gestures
            const [manualCardNumber, setManualCardNumber] = useState(null);
            const [cardDetailEdit, setCardDetailEdit] = useState(null);
            const [originalCardDetail, setOriginalCardDetail] = useState(null);
            const [variantValidationModal, setVariantValidationModal] = useState(null);  // {cardNum, aiVariant, suggestedVariant}
            const [pendingCardToAdd, setPendingCardToAdd] = useState(null);  // {cardNum, variant, analysis}
            const [addCardCooldown, setAddCardCooldown] = useState(0);  // Rate limiting for adding cards
            const [isMobile, setIsMobile] = useState(window.innerWidth < 768);  // Mobile detection state
            const [showAddCardManual, setShowAddCardManual] = useState(false);  // Manual card addition modal
            const [manualCardData, setManualCardData] = useState({ cardNumber: '', variant: 'Base', serialNumber: '', cardTitle: '', driverName: '', value: '' });  // Card data being entered
            const [loadingCardDetails, setLoadingCardDetails] = useState(false);  // Loading state for card details
            const [collapsedSections, setCollapsedSections] = useState({});  // Track which sections are collapsed
            const [showGradeCamera, setShowGradeCamera] = useState(false);  // Grade camera modal
            const [gradeCameraAutoOpen, setGradeCameraAutoOpen] = useState(() => localStorage.getItem('f1-grade-camera-auto') === 'true');  // Persist camera toggle
            const [gradeCardContext, setGradeCardContext] = useState(null);  // {cardNum, variant} being graded
            const [returnTo, setReturnTo] = useState(null);  // Track where user came from (e.g. 'dashboard')
            const [scannerCameraActive, setScannerCameraActive] = useState(false);  // Scanner camera live view
            const [scannerCameraStream, setScannerCameraStream] = useState(null);  // Scanner camera stream
            const [scannerCapturedImages, setScannerCapturedImages] = useState([]);  // Images captured from scanner camera
            const [scannerMode, setScannerMode] = useState('camera');  // 'camera' or 'upload'
            const scannerVideoRef = React.useRef(null);
            const [availableCameras, setAvailableCameras] = useState([]);
            const [selectedCameraId, setSelectedCameraId] = useState(() => localStorage.getItem('f1-preferred-camera') || '');

            // Toast notification state â€” lightweight, non-blocking user feedback
            const [toastMessage, setToastMessage] = useState(null);
            const toastTimerRef = useRef(null);
            const showToast = (message, durationMs = 5000) => {
                if (toastTimerRef.current) clearTimeout(toastTimerRef.current);
                setToastMessage(message);
                toastTimerRef.current = setTimeout(() => setToastMessage(null), durationMs);
            };

            // Enumerate available cameras
            const enumerateCameras = async () => {
                try {
                    // Request a temporary stream to trigger permission prompt (required before enumerateDevices shows labels)
                    const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
                    tempStream.getTracks().forEach(t => t.stop());

                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const cameras = devices.filter(d => d.kind === 'videoinput');
                    setAvailableCameras(cameras);

                    // If saved camera is not available, clear selection (will fall back to default)
                    const savedId = localStorage.getItem('f1-preferred-camera');
                    if (savedId && !cameras.find(c => c.deviceId === savedId)) {
                        setSelectedCameraId('');
                        localStorage.removeItem('f1-preferred-camera');
                    }
                } catch (err) {
                    console.error('Could not enumerate cameras:', err);
                }
            };

            // Build video constraints using selected camera
            const getCameraConstraints = () => {
                // Read from localStorage to avoid stale closure issues
                const cameraId = localStorage.getItem('f1-preferred-camera') || selectedCameraId;
                if (cameraId) {
                    return { video: { deviceId: { exact: cameraId }, width: { ideal: 1920 }, height: { ideal: 1080 } } };
                }
                return { video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } } };
            };

            // Handle camera selection change
            const handleCameraChange = (deviceId) => {
                setSelectedCameraId(deviceId);
                if (deviceId) {
                    localStorage.setItem('f1-preferred-camera', deviceId);
                } else {
                    localStorage.removeItem('f1-preferred-camera');
                }
            };

            // Enumerate cameras on mount
            useEffect(() => {
                enumerateCameras();
            }, []);

            // Make current state accessible to chatbot with debugging
            useEffect(() => {
                // Set global state immediately
                window.currentAppState = {
                    selectedCard,
                    collection,
                    showImageUpload,
                    cardData
                };
                
                // Force status update
                setTimeout(() => {
                    // Also update chatbot interface if it exists
                    if (window.updateChatbotInterface) {
                        window.updateChatbotInterface();
                    }
                }, 200);
                
            }, [selectedCard, collection, showImageUpload, cardData]);

            // Initialize universal chatbot with context provider  
            useEffect(() => {
                // Set initial global state
                window.currentAppState = {
                    selectedCard,
                    collection,
                    showImageUpload,
                    cardData
                };
                
                // Function to generate fresh context info using global state
                window.generateContextInfo = () => {
                    const state = window.currentAppState || {};
                    
                    let contextInfo = "You are an AI assistant integrated into an F1 card collection tracking application. ";
                    
                    // Add current card context if available
                    if (state.selectedCard) {
                        const cardKey = `card-${state.selectedCard.num}`;
                        const cardData = (state.collection || {})[cardKey] || {};
                        const totalCount = Object.keys(cardData).filter(k => !k.startsWith('_')).reduce((sum, v) => sum + (cardData[v] || 0), 0);
                        
                        contextInfo += `The user is currently viewing Card #${state.selectedCard.num} - ${state.selectedCard.name}`;
                        if (state.selectedCard.team) contextInfo += ` (${state.selectedCard.team})`;
                        contextInfo += `. This card is from the ${state.selectedCard.subset || 'Unknown'} subset.`;
                        
                        if (totalCount > 0) {
                            contextInfo += ` The user owns ${totalCount} cop${totalCount === 1 ? 'y' : 'ies'} of this card`;
                            const variants = Object.keys(cardData).filter(k => !k.startsWith('_') && cardData[k] > 0);
                            if (variants.length > 0) {
                                contextInfo += ` in these variants: ${variants.map(v => `${v} (${cardData[v]})`).join(', ')}`;
                            }
                            contextInfo += `.`;
                        } else {
                            contextInfo += ` The user does not currently own this card.`;
                        }

                        if (state.selectedCard.rookie) {
                            contextInfo += ` This is a rookie card.`;
                        }
                    } else {
                        contextInfo += `The user is browsing their collection but hasn't selected a specific card yet. `;
                    }

                    // Add collection context
                    const collection = state.collection || {};
                    const totalCards = Object.keys(collection).filter(k => !k.startsWith('_')).length;
                    const totalCopies = Object.keys(collection).reduce((total, cardKey) => {
                        if (cardKey.startsWith('_')) return total;
                        const variants = collection[cardKey] || {};
                        return total + Object.keys(variants).filter(k => !k.startsWith('_')).reduce((sum, v) => sum + (variants[v] || 0), 0);
                    }, 0);
                    
                    if (totalCards > 0) {
                        contextInfo += ` The user's collection contains ${totalCards} unique cards and ${totalCopies} total cards from the 2025 Topps Chrome F1 set.`;

                        // Build comprehensive driver ownership summary so chatbot knows exact counts
                        const driverCounts = {};
                        const ownedCardKeys = Object.keys(collection).filter(k => !k.startsWith('_'));
                        ownedCardKeys.forEach(cardKey => {
                            const cardNum = cardKey.replace('card-', '');
                            const card = (state.cardData || []).find(c => c.num === cardNum);
                            const variants = collection[cardKey] || {};
                            const cardTotal = Object.keys(variants).filter(k => !k.startsWith('_')).reduce((sum, v) => sum + (variants[v] || 0), 0);
                            if (card && cardTotal > 0) {
                                const name = card.name;
                                if (!driverCounts[name]) driverCounts[name] = { total: 0, cards: [] };
                                driverCounts[name].total += cardTotal;
                                const variantDetails = Object.keys(variants)
                                    .filter(k => !k.startsWith('_') && variants[k] > 0)
                                    .map(v => `${v}:${variants[v]}`).join(', ');
                                driverCounts[name].cards.push(`#${cardNum} (${variantDetails})`);
                            }
                        });

                        // Include full driver breakdown
                        const driverSummaries = Object.entries(driverCounts)
                            .sort((a, b) => b[1].total - a[1].total)
                            .map(([name, info]) => `${name}: ${info.total} total [${info.cards.join('; ')}]`);
                        if (driverSummaries.length > 0) {
                            contextInfo += ` COMPLETE COLLECTION BREAKDOWN BY DRIVER/CARD: ${driverSummaries.join(' | ')}`;
                        }
                    } else {
                        contextInfo += ` The user's collection is empty - they haven't added any cards yet.`;
                    }

                    // Add interface context
                    if (state.showImageUpload) {
                        contextInfo += ` The user currently has the AI Scanner open.`;
                    }
                    
                    contextInfo += ` IMPORTANT: You can see their collection data and current card. Do not say you cannot see what they're looking at. Provide specific help based on what you know about their collection and current selection.`;
                    
                    return contextInfo;
                };

                // Initialize chatbot only once
                if (!window.chatbotInitialized) {
                    window.initializeChatbot();
                    window.chatbotInitialized = true;
                }
            }, []); // Only run once on mount

            // Check for card to open from dashboard
            useEffect(() => {
                const openCardData = localStorage.getItem('openCardOnLoad');
                if (openCardData) {
                    try {
                        const { cardNum, card, timestamp, returnTo: source } = JSON.parse(openCardData);
                        // Only auto-open if timestamp is recent (within 5 seconds)
                        if (Date.now() - timestamp < 5000) {
                            const cardFromDatabase = cardData.find(c => c.num === cardNum);
                            if (cardFromDatabase) {
                                setSelectedCard(cardFromDatabase);
                                if (source) setReturnTo(source);
                            }
                        }
                        // Clear the localStorage item
                        localStorage.removeItem('openCardOnLoad');
                    } catch (error) {
                        console.error('Error parsing openCardOnLoad data:', error);
                        localStorage.removeItem('openCardOnLoad');
                    }
                }
            }, [cardData]);

            // Check for variant filter from dashboard
            useEffect(() => {
                const filterData = localStorage.getItem('filterVariantOnLoad');
                if (filterData) {
                    try {
                        const { variant, timestamp } = JSON.parse(filterData);
                        if (Date.now() - timestamp < 5000) {
                            setFilterVariants([variant]);
                            setShowOwnedOnly(true);
                        }
                        localStorage.removeItem('filterVariantOnLoad');
                    } catch (error) {
                        localStorage.removeItem('filterVariantOnLoad');
                    }
                }
            }, []);

            // Detect mobile device
            useEffect(() => {
                const handleResize = () => {
                    setIsMobile(window.innerWidth < 768);
                };
                
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);
            
            // Fuzzy string matching - returns similarity score 0-1
            const fuzzyMatch = (str1, str2) => {
                const s1 = str1.toLowerCase();
                const s2 = str2.toLowerCase();
                
                // Exact match
                if (s1 === s2) return 1.0;
                
                // Check if one contains the other
                if (s1.includes(s2) || s2.includes(s1)) return 0.9;
                
                // Levenshtein distance based similarity
                const longer = s1.length > s2.length ? s1 : s2;
                const shorter = s1.length > s2.length ? s2 : s1;
                
                if (longer.length === 0) return 1.0;
                
                const editDistance = getEditDistance(longer, shorter);
                return (longer.length - editDistance) / longer.length;
            };

            // Calculate Levenshtein distance
            const getEditDistance = (s1, s2) => {
                const costs = [];
                for (let i = 0; i <= s1.length; i++) {
                    let lastValue = i;
                    for (let j = 0; j <= s2.length; j++) {
                        if (i === 0) {
                            costs[j] = j;
                        } else if (j > 0) {
                            let newValue = costs[j - 1];
                            if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
                                newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                            }
                            costs[j - 1] = lastValue;
                            lastValue = newValue;
                        }
                    }
                    if (i > 0) costs[s2.length] = lastValue;
                }
                return costs[s2.length];
            };

            // Find best matching variant or return null if no good match
            const findBestVariantMatch = (aiVariant) => {
                let bestMatch = null;
                let bestScore = 0;
                
                OFFICIAL_VARIANTS.forEach(official => {
                    const score = fuzzyMatch(aiVariant, official);
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = official;
                    }
                });
                
                // Only return match if score is above 0.6 (60% similarity)
                return bestScore >= 0.6 ? bestMatch : null;
            };
            const importInputRef = useRef(null);
            const fileInputRef = useRef(null);
            const menuRef = useRef(null);

            useEffect(() => {
                loadCollection();
                checkServer();
                document.addEventListener('click', handleClickOutside);
                return () => document.removeEventListener('click', handleClickOutside);
            }, []);

            function handleClickOutside(event) {
                if (menuRef.current && !menuRef.current.contains(event.target)) {
                    setShowMenuDropdown(false);
                }
            }

            useEffect(() => {
                // Calculate header height and set page label position
                const updatePageLabelPosition = () => {
                    const header = document.querySelector('.sticky.top-0.z-30');
                    if (header) {
                        const headerHeight = header.offsetHeight;
                        // Add 20px buffer below header
                        const pageNumberTop = headerHeight + 20;
                        const pageDividerTop = pageNumberTop + 16; // Additional spacing for divider
                        document.documentElement.style.setProperty('--page-number-top', `${pageNumberTop}px`);
                        document.documentElement.style.setProperty('--page-divider-top', `${pageDividerTop}px`);
                    }
                };

                // Initial calculation
                updatePageLabelPosition();

                // Recalculate on window resize
                window.addEventListener('resize', updatePageLabelPosition);
                
                // Small delay to ensure DOM is fully rendered
                setTimeout(updatePageLabelPosition, 100);

                return () => window.removeEventListener('resize', updatePageLabelPosition);
            }, [serverOnline]); // Recalculate when server status changes (affects header height)

            const checkServer = async () => {
                try {
                    const response = await fetch('https://f1-card-tracker-backend-1.onrender.com/api/test');
                    const data = await response.json();
                    setServerOnline(data.status === 'ok' && data.apiKeySet);
                } catch (error) {
                    setServerOnline(false);
                }
            };

            const [userId, setUserId] = useState(null);

            const loadCollection = async () => {
            try {
                // Load from localStorage FIRST (instant display, includes analyses)
                let localCollection = {};
                const saved = localStorage.getItem('f1-collection-pro-v2');
                if (saved) {
                    try {
                        localCollection = JSON.parse(saved);
                        setCollection(localCollection);
                        console.log('âœ… Collection loaded from localStorage (instant)');
                    } catch (e) {
                        console.error('Error parsing localStorage:', e);
                        setCollection({});
                    }
                }

                // Set user ID
                let id = 'cincymed-f1-collection';
                localStorage.setItem('cincymed-f1-user-id', id);
                setUserId(id);

                // Sync from MongoDB in background (5 second timeout).
                // MongoDB now stores only card counts (no analyses/gradeReports).
                // We merge MongoDB counts with locally-stored analyses.
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000);

                    const response = await fetch(`https://f1-card-tracker-backend-1.onrender.com/api/collection/${id}`, {
                        method: 'GET',
                        headers: getAuthHeaders(),
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);

                    const data = await response.json();
                    if (data.cards && Object.keys(data.cards).length > 0) {
                        // Merge MongoDB counts with local analyses/gradeReports
                        const merged = mergeMongoWithLocal(data.cards, localCollection);
                        setCollection(merged);
                        localStorage.setItem('f1-collection-pro-v2', JSON.stringify(merged));
                        console.log('âœ… Collection synced from MongoDB (counts merged with local analyses)');
                    }
                } catch (error) {
                    console.log('MongoDB sync skipped (using localStorage):', error.message);
                }
            } catch (error) {
                console.error('Error loading collection:', error);
                setCollection({});
            }
            };

            const cleanupCollection = (coll) => {
                console.log('ðŸ§¹ cleanupCollection input:', Object.keys(coll).length, 'keys');
                const cleaned = { ...coll };
                
                Object.keys(cleaned).forEach(cardKey => {
                    if (cardKey.startsWith('_')) return; // Skip metadata
                    
                    const cardData = cleaned[cardKey];
                    
                    // Remove variants with 0 or negative count
                    Object.keys(cardData).forEach(variant => {
                        if (variant.startsWith('_')) return; // Skip metadata like _analyses
                        
                        if (cardData[variant] <= 0) {
                            console.log(`Removing ${cardKey} ${variant} (count was ${cardData[variant]})`);
                            delete cardData[variant];
                        }
                    });
                    
                    // If card has no valid variants left (only metadata), remove the card entry
                    const hasVariants = Object.keys(cardData).some(key => !key.startsWith('_') && cardData[key] > 0);
                    if (!hasVariants) {
                        console.log(`Removing empty card entry: ${cardKey}`);
                        delete cleaned[cardKey];
                    }
                });
                
                console.log('ðŸ§¹ cleanupCollection output:', Object.keys(cleaned).length, 'keys');
                if (Object.keys(cleaned).length === 0) {
                    console.error('âš ï¸ WARNING: cleanupCollection returned empty collection!');
                }
                return cleaned;
            };

            // Strip _analyses and _gradeReports from collection for MongoDB storage.
            // MongoDB has a 16MB document size limit; analyses grow unboundedly and
            // can easily exceed it. Card counts are tiny; analyses live in localStorage
            // and are preserved by mergeMongoWithLocal on each device.
            const stripMetadataForMongo = (coll) => {
                const stripped = {};
                Object.keys(coll).forEach(cardKey => {
                    if (cardKey.startsWith('_')) return;
                    const cardData = coll[cardKey];
                    const cardEntry = {};
                    Object.keys(cardData).forEach(key => {
                        // Only include variant counts â€” skip all _-prefixed metadata
                        if (!key.startsWith('_')) {
                            cardEntry[key] = cardData[key];
                        }
                    });
                    if (Object.keys(cardEntry).length > 0) {
                        stripped[cardKey] = cardEntry;
                    }
                });
                return stripped;
            };

            // Merge MongoDB data with locally-stored data.
            // Uses Math.max for counts so no card/variant is ever lost:
            //   - Local-only cards (e.g. scan failed to POST) are preserved
            //   - Local-only variants (e.g. new variant added, POST failed) are preserved
            //   - MongoDB counts that are higher (e.g. from another device) win
            // Local analyses/gradeReports always take priority; fall back to MongoDB.
            const mergeMongoWithLocal = (mongoColl, localColl) => {
                const merged = {};
                const allKeys = new Set([...Object.keys(mongoColl), ...Object.keys(localColl)]);
                allKeys.forEach(cardKey => {
                    if (cardKey.startsWith('_')) return;
                    const mongoCard = mongoColl[cardKey] || {};
                    const localCard = localColl[cardKey] || {};

                    const mergedCard = {};

                    // Merge variant counts from BOTH sources using Math.max.
                    // This ensures local-only cards/variants survive even if the
                    // MongoDB POST failed (429, cold-start, network error).
                    const allVariants = new Set([
                        ...Object.keys(mongoCard).filter(k => !k.startsWith('_')),
                        ...Object.keys(localCard).filter(k => !k.startsWith('_'))
                    ]);
                    allVariants.forEach(variant => {
                        const mongoCount = (typeof mongoCard[variant] === 'number') ? mongoCard[variant] : 0;
                        const localCount = (typeof localCard[variant] === 'number') ? localCard[variant] : 0;
                        const best = Math.max(mongoCount, localCount);
                        if (best > 0) {
                            mergedCard[variant] = best;
                        }
                    });

                    // Merge analyses: prefer local if present, fall back to MongoDB
                    const localAnalyses = localCard._analyses;
                    const mongoAnalyses = mongoCard._analyses;
                    if (localAnalyses && Object.keys(localAnalyses).length > 0) {
                        mergedCard._analyses = localAnalyses;
                    } else if (mongoAnalyses && Object.keys(mongoAnalyses).length > 0) {
                        mergedCard._analyses = mongoAnalyses;
                    }

                    // Merge grade reports: prefer local if present, fall back to MongoDB
                    const localGrades = localCard._gradeReports;
                    const mongoGrades = mongoCard._gradeReports;
                    if (localGrades && Object.keys(localGrades).length > 0) {
                        mergedCard._gradeReports = localGrades;
                    } else if (mongoGrades && Object.keys(mongoGrades).length > 0) {
                        mergedCard._gradeReports = mongoGrades;
                    }

                    if (Object.keys(mergedCard).length > 0) {
                        merged[cardKey] = mergedCard;
                    }
                });
                return merged;
            };

            // Trim analysis arrays to keep only the most recent N entries per variant
            const trimAnalyses = (coll, maxPerVariant = 3) => {
                Object.keys(coll).forEach(cardKey => {
                    if (cardKey.startsWith('_')) return;
                    const cardData = coll[cardKey];
                    if (cardData._analyses) {
                        Object.keys(cardData._analyses).forEach(variant => {
                            const arr = cardData._analyses[variant];
                            if (Array.isArray(arr) && arr.length > maxPerVariant) {
                                cardData._analyses[variant] = arr.slice(-maxPerVariant);
                            }
                        });
                    }
                });
                return coll;
            };

            const saveCollection = (newCollection) => {
                try {
                    const cardCountBefore = Object.keys(newCollection).filter(k => k.startsWith('card-')).length;
                    console.log('ðŸ’¾ saveCollection called with:', cardCountBefore, 'cards');
                    
                    const cleanedCollection = cleanupCollection(newCollection);
                    const cardCountAfter = Object.keys(cleanedCollection).filter(k => k.startsWith('card-')).length;
                    
                    // Count total copies across all variants
                    let totalCopies = 0;
                    Object.keys(cleanedCollection).forEach(key => {
                        if (key.startsWith('card-')) {
                            const card = cleanedCollection[key];
                            Object.keys(card).forEach(variant => {
                                if (!variant.startsWith('_') && card[variant] > 0) {
                                    totalCopies += card[variant];
                                }
                            });
                        }
                    });
                    
                    console.log('ðŸ§¹ After cleanup:', cardCountAfter, 'cards');
                    console.log('ðŸ“Š Total copies:', totalCopies);
                    console.log('âš ï¸ CARDS LOST IN CLEANUP:', cardCountBefore - cardCountAfter);
                    
                    // Trim analyses to last 3 per variant to prevent unbounded growth
                    trimAnalyses(cleanedCollection, 3);

                    setCollection(cleanedCollection);
                    console.log('ðŸ”„ setCollection called');

                    // Save full collection (with analyses) to localStorage
                    const jsonStr = JSON.stringify(cleanedCollection);
                    localStorage.setItem('f1-collection-pro-v2', jsonStr);
                    console.log('âœ… Saved to localStorage:', jsonStr.length, 'bytes');

                    // Save counts-only to MongoDB (no analyses/gradeReports).
                    // Analyses live in localStorage and are preserved by mergeMongoWithLocal.
                    const mongoData = stripMetadataForMongo(cleanedCollection);

                    const mongoPayloadSize = JSON.stringify({ cards: mongoData }).length;
                    console.log('ðŸ“¤ MongoDB payload size:', mongoPayloadSize, 'bytes (counts only)');

                    saveToMongoDB(mongoData);
                    
                } catch (error) {
                    console.error('Error saving collection:', error);
                    alert('âŒ Error saving collection:\n' + error.message);
                }
            };

            const getCardKey = (cardNum) => `card-${cardNum}`;
            
            const getCardInventory = (cardNum) => collection[getCardKey(cardNum)] || {};
            
            const getTotalCount = (cardNum) => {
                const inventory = getCardInventory(cardNum);
                return Object.keys(inventory)
                    .filter(key => !key.startsWith('_'))
                    .reduce((sum, variant) => sum + (inventory[variant] || 0), 0);
            };

            // Count total cards of a specific variant across the entire collection
            const getVariantTotalCount = (variant) => {
                let total = 0;
                Object.keys(collection).forEach(cardKey => {
                    if (cardKey.startsWith('_')) return;
                    const count = collection[cardKey][variant];
                    if (count > 0) total += count;
                });
                return total;
            };

            const getVariantBreakdown = (cardNum) => {
                const inventory = getCardInventory(cardNum);
                return Object.keys(inventory)
                    .filter(key => !key.startsWith('_') && inventory[key] > 0)
                    .map(variant => ({
                        variant: variant,
                        count: inventory[variant],
                        style: variantStyles[variant] || { bg: "bg-gray-500", text: "??", color: "#6b7280" }
                    }));
            };

            const getTotalCollectionCount = () => {
                return Object.keys(collection)
                    .filter(key => !key.startsWith('_'))
                    .reduce((sum, cardKey) => {
                        const cardInventory = collection[cardKey];
                        return sum + Object.keys(cardInventory)
                            .filter(key => !key.startsWith('_'))
                            .reduce((s, variant) => s + (cardInventory[variant] || 0), 0);
                    }, 0);
            };

            // Analyze card with LLM for value estimation
            const analyzeCardValue = async (cardNum, variant) => {
                const card = cardData.find(c => c.num === cardNum);
                if (!card) return null;

                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: getAuthHeaders(),
                        body: JSON.stringify({
                            model: "claude-sonnet-4-5-20250929",
                            max_tokens: 500,
                            messages: [{
                                role: "user",
                                content: `Provide a brief value analysis for this F1 trading card:
Card: #${card.num} ${card.name}
Team: ${card.team || 'N/A'}
Variant: ${variant}
Subset: ${card.subset}
${card.rookie ? 'This is a ROOKIE card' : ''}

Please provide:
1. Current market value range (Raw, PSA 9, PSA 10)
2. Brief explanation of market factors affecting value

VALUE ESTIMATES:
Raw: $X-Y
PSA 9: $X-Y
PSA 10: $X-Y

COMPARABLE SALES:
List the top 5 most pertinent recent sales. Sort by closest match to this card # and variant first, then by most recent date. For each sale include:
- Card # and variant sold
- Sale date
- Sale price
- Data source (eBay, PSA Price Guide, TCGPlayer, COMC, Beckett, 130point, etc.)
Format each as: "#[card#] [variant] - $[price] on [date] ([source])"

VALUE WEIGHTING PRIORITY (most to least important):
- Sales of this EXACT card (same year, driver/card #, subset, variant) carry the MOST weight
- Then sales of the same driver in the same set with different variants
- Then sales of similar cards (same set, comparable drivers/variants)
- General market trends carry least weight

Keep response under 200 words total.`
                            }]
                        })
                    });

                    const data = await response.json();
                    if (data.content) {
                        const analysisText = data.content
                            .filter(block => block.type === 'text')
                            .map(block => block.text)
                            .join('\n\n')
                            .trim();
                        return analysisText || null;
                    }
                    return null;
                } catch (error) {
                    console.error('Analysis error:', error);
                    return null;
                }
            };

            // Toggle a card's selection in bulk mode
            const toggleBulkSelect = (cardNum) => {
                setBulkSelectedCards(prev => {
                    const next = new Set(prev);
                    if (next.has(cardNum)) {
                        next.delete(cardNum);
                    } else {
                        next.add(cardNum);
                    }
                    return next;
                });
            };

            // Handle bulk analyze button click â€” toggles between select mode and run mode
            const handleBulkAnalyzeClick = () => {
                if (bulkAnalyzing) return; // already running

                if (!bulkSelectMode) {
                    // Enter selection mode
                    setBulkSelectMode(true);
                    setBulkSelectedCards(new Set());
                } else {
                    // Selection mode is active â€” run analysis on selected cards
                    if (bulkSelectedCards.size === 0) {
                        // Nothing selected, just exit selection mode
                        setBulkSelectMode(false);
                        return;
                    }
                    runBulkAnalysis();
                }
            };

            // Cancel bulk selection mode
            const cancelBulkSelect = () => {
                setBulkSelectMode(false);
                setBulkSelectedCards(new Set());
            };

            const runBulkAnalysis = async () => {
                // Gather all unanalyzed variants for selected cards
                const cardsToAnalyze = [];

                bulkSelectedCards.forEach(cardNum => {
                    const key = getCardKey(cardNum);
                    const cardEntry = collection[key];
                    if (!cardEntry) return;

                    Object.keys(cardEntry).filter(k => !k.startsWith('_')).forEach(variant => {
                        if (cardEntry[variant] && cardEntry[variant] > 0) {
                            const hasAnalysis = cardEntry._analyses && cardEntry._analyses[variant] && cardEntry._analyses[variant].length > 0;
                            if (!hasAnalysis) {
                                cardsToAnalyze.push({ cardNum, variant });
                            }
                        }
                    });
                });

                if (cardsToAnalyze.length === 0) {
                    alert('All selected cards already have analyses!');
                    setBulkSelectMode(false);
                    setBulkSelectedCards(new Set());
                    return;
                }

                setBulkSelectMode(false);
                setBulkAnalyzing(true);
                setBulkAnalyzeProgress({ current: 0, total: cardsToAnalyze.length });

                let updatedCollection = { ...collection };

                for (let i = 0; i < cardsToAnalyze.length; i++) {
                    const { cardNum, variant } = cardsToAnalyze[i];
                    setBulkAnalyzeProgress({ current: i + 1, total: cardsToAnalyze.length });

                    try {
                        const analysis = await analyzeCardValue(cardNum, variant);
                        if (analysis) {
                            const key = getCardKey(cardNum);
                            if (!updatedCollection[key]._analyses) updatedCollection[key]._analyses = {};
                            if (!updatedCollection[key]._analyses[variant]) updatedCollection[key]._analyses[variant] = [];
                            updatedCollection[key]._analyses[variant].push({
                                id: Date.now(),
                                addedDate: new Date().toISOString(),
                                analysis: analysis
                            });
                            saveCollection(updatedCollection);
                        }
                    } catch (error) {
                        console.error(`Bulk analyze error for card ${cardNum} ${variant}:`, error);
                    }

                    // Small delay between API calls to avoid rate limiting
                    if (i < cardsToAnalyze.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }

                setBulkAnalyzing(false);
                setBulkAnalyzeProgress({ current: 0, total: 0 });
                setBulkSelectedCards(new Set());
            };

            const reanalyzeCardValue = async (cardNum, variant) => {
                const card = cardData.find(c => c.num === cardNum);
                if (!card) return null;

                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: getAuthHeaders(),
                        body: JSON.stringify({
                            model: "claude-opus-4-5-20251101",
                            max_tokens: 3000,
                            tools: [{
                                type: "web_search_20250305",
                                name: "web_search"
                            }],
                            messages: [{
                                role: "user",
                                content: `You are a trading card market expert. Use web search to find current market data for this 2025 Topps Chrome F1 card, then respond with your analysis.

Card #${card.num}: ${card.name}
Team: ${card.team || 'N/A'}
Variant: ${variant}
Subset: ${card.subset}
${card.rookie ? 'ROOKIE CARD' : ''}

FORMATTING RULES - follow exactly:
- Plain text only. NO markdown (no **, no ##, no *, no _)
- Use plain hyphens (-) in value ranges, NOT en-dashes or em-dashes
- Section headers must be ALL CAPS followed by a colon on their own line
- Value format must be exactly: Raw: $X-Y  (dollar sign, number, hyphen, number)

Respond using ONLY this structure:

CARD IDENTIFICATION:
[Driver name, team, card number, variant, and any special notes like rookie or serial number]

VARIANT & RARITY:
[What this variant is, how rare it is, print run if applicable, and how it compares to other variants]

VALUE ESTIMATES:
Raw: $X-Y
PSA 9: $X-Y
PSA 10: $X-Y

COMPARABLE SALES:
1. #[card#] [variant] - $[price] on [date] ([source])
2. #[card#] [variant] - $[price] on [date] ([source])
3. #[card#] [variant] - $[price] on [date] ([source])
4. #[card#] [variant] - $[price] on [date] ([source])
5. #[card#] [variant] - $[price] on [date] ([source])
[List top 5 most pertinent sales. Sort by: exact card/variant match first, then most recent date. Include card #, variant, price, date, and source (eBay, PSA Price Guide, TCGPlayer, COMC, Beckett, 130point, StockX)]

VALUE SOURCES & DERIVATION:
[How values were calculated: "Average of X comparable sales from Y sources." Include weighting notes.]

COLLECTIBILITY:
[Why collectors want this card, investment potential, market trend summary]

VALUE WEIGHTING: Weight most heavily sales of this exact card (same card #, variant, year). Then same driver different variant. Then similar cards in set.`
                            }]
                        })
                    });

                    const data = await response.json();
                    if (data.content) {
                        // Extract text from all content blocks (including after tool use)
                        const analysisText = data.content
                            .filter(block => block.type === 'text')
                            .map(block => block.text)
                            .join('\n\n')
                            .trim();
                        
                        return analysisText || null;
                    }
                    return null;
                } catch (error) {
                    console.error('Reanalysis error:', error);
                    return null;
                }
            };

            // Lookup card details (driver name, card title, value) from web search
            const lookupCardDetails = async (cardNum) => {
                try {
                    setLoadingCardDetails(true);
                    
                    // Use Claude API via backend proxy to find card details
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: getAuthHeaders(),
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-5-20250929',
                            max_tokens: 500,
                            tools: [{ type: 'web_search', name: 'web_search' }],
                            messages: [{
                                role: 'user',
                                content: `Find information about 2025 Topps Chrome F1 card #${cardNum}. Respond ONLY with JSON in this format:
{
  "cardTitle": "Card title or driver name",
  "driverName": "Driver name if applicable",
  "value": "Current market value estimate e.g. $5-10"
}

If you cannot find the exact card, provide your best estimate based on similar cards in the set.`
                            }]
                        })
                    });

                    const data = await response.json();
                    let details = { cardTitle: '', driverName: '', value: '' };
                    
                    if (data.content) {
                        const fullText = data.content
                            .map(block => {
                                if (block.type === 'text') return block.text;
                                return '';
                            })
                            .join('');
                        
                        // Extract JSON from response
                        const jsonMatch = fullText.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            try {
                                details = JSON.parse(jsonMatch[0]);
                            } catch (e) {
                                console.warn('Could not parse card details JSON');
                            }
                        }
                    }
                    
                    setLoadingCardDetails(false);
                    return details;
                } catch (error) {
                    console.error('Card details lookup error:', error);
                    setLoadingCardDetails(false);
                    return { cardTitle: '', driverName: '', value: '' };
                }
            };

            const addCard = async (cardNum, variant, analysis = null, gradeReport = null) => {
                console.log('ðŸ” addCard called:', { cardNum, variant, analysisExists: !!analysis });
                console.log('ðŸ“Š Current collection state:', Object.keys(collection).length, 'cards');
                console.log('ðŸ“Š Current collection card count:', Object.keys(collection).filter(k => k.startsWith('card-')).length);
                
                const key = getCardKey(cardNum);
                const newCollection = { ...collection };
                if (!newCollection[key]) newCollection[key] = {};
                
                const isFirstOfVariant = !newCollection[key][variant] || newCollection[key][variant] === 0;
                
                if (!newCollection[key][variant]) {
                    newCollection[key][variant] = 0;
                }
                newCollection[key][variant]++;
                
                console.log('âœ… Updated collection:', { key, variant, count: newCollection[key][variant] });
                console.log('ðŸ“ BEFORE cleanup - total cards:', Object.keys(newCollection).filter(k => k.startsWith('card-')).length);
                console.log('ðŸ“ BEFORE cleanup - card #' + cardNum + ' variant "' + variant + '" count:', newCollection[key][variant]);
                
                if (analysis) {
                    if (!newCollection[key]._analyses) newCollection[key]._analyses = {};
                    if (!newCollection[key]._analyses[variant]) newCollection[key]._analyses[variant] = [];
                    newCollection[key]._analyses[variant].push({
                        id: Date.now(),
                        addedDate: new Date().toISOString(),
                        analysis: analysis
                    });
                }

                if (gradeReport) {
                    if (!newCollection[key]._gradeReports) newCollection[key]._gradeReports = {};
                    newCollection[key]._gradeReports[variant] = gradeReport;
                }
                
                saveCollection(newCollection);

                // If this is the first card of this variant and we have server, analyze it
                if (isFirstOfVariant && serverOnline && !analysis) {
                    const analyzeKey = `${cardNum}-${variant}`;
                    setAnalyzingCards(prev => ({ ...prev, [analyzeKey]: true }));
                    
                    const cardAnalysis = await analyzeCardValue(cardNum, variant);
                    
                    setAnalyzingCards(prev => {
                        const updated = { ...prev };
                        delete updated[analyzeKey];
                        return updated;
                    });
                    
                    if (cardAnalysis) {
                        const updatedCollection = { ...newCollection };
                        if (!updatedCollection[key]._analyses) updatedCollection[key]._analyses = {};
                        if (!updatedCollection[key]._analyses[variant]) updatedCollection[key]._analyses[variant] = [];
                        updatedCollection[key]._analyses[variant].push({
                            id: Date.now(),
                            addedDate: new Date().toISOString(),
                            analysis: cardAnalysis
                        });
                        saveCollection(updatedCollection);
                    }
                }
            };

            const removeCard = (cardNum, variant) => {
                const key = getCardKey(cardNum);
                const newCollection = { ...collection };
                if (newCollection[key] && newCollection[key][variant] > 0) {
                    newCollection[key][variant]--;
                    if (newCollection[key][variant] === 0) {
                        delete newCollection[key][variant];
                    }
                    saveCollection(newCollection);
                }
            };

            const exportCollection = () => {
                const dataStr = JSON.stringify(collection, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                const timestamp = new Date().toISOString().split('T')[0];
                link.download = `f1-collection-backup-${timestamp}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            };

            const importCollection = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        saveCollection(imported);
                        alert(`âœ… Collection imported successfully!\n\nCards restored: ${Object.keys(imported).filter(k => !k.startsWith('_')).length}`);
                    } catch (error) {
                        alert('âŒ Error importing file. Make sure it\'s a valid backup file.');
                        console.error('Import error:', error);
                    }
                };
                reader.readAsText(file);
                event.target.value = ''; // Reset input
            };

            // Compress image to reduce file size for API
            const compressImage = async (dataUrl, maxWidth = 1200, quality = 0.8) => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let width = img.width;
                        let height = img.height;
                        
                        // Resize if too large
                        if (width > maxWidth) {
                            height = (height * maxWidth) / width;
                            width = maxWidth;
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // Convert to JPEG with quality setting
                        const compressed = canvas.toDataURL('image/jpeg', quality);
                        resolve(compressed);
                    };
                    img.src = dataUrl;
                });
            };

            // Scanner camera functions
            const startScannerCamera = async () => {
                try {
                    const constraints = getCameraConstraints();
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    setScannerCameraStream(stream);
                    setScannerCameraActive(true);
                } catch (err) {
                    console.error('Camera access error:', err);
                    // If preferred camera failed, try default
                    if (selectedCameraId) {
                        try {
                            const stream = await navigator.mediaDevices.getUserMedia({
                                video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } }
                            });
                            setScannerCameraStream(stream);
                            setScannerCameraActive(true);
                            setSelectedCameraId('');
                            localStorage.removeItem('f1-preferred-camera');
                            return;
                        } catch (fallbackErr) {
                            console.error('Fallback camera also failed:', fallbackErr);
                        }
                    }
                    alert('Could not access camera. Please use file upload instead.');
                    setScannerMode('upload');
                }
            };

            const stopScannerCamera = () => {
                if (scannerCameraStream) {
                    scannerCameraStream.getTracks().forEach(track => track.stop());
                    setScannerCameraStream(null);
                }
                setScannerCameraActive(false);
            };

            const captureScannerPhoto = async () => {
                if (!scannerVideoRef.current) return;
                const video = scannerVideoRef.current;
                // Wait for video to have actual dimensions
                if (!video.videoWidth || !video.videoHeight) {
                    console.warn('Video not ready yet, waiting...');
                    return;
                }
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                canvas.getContext('2d').drawImage(video, 0, 0);
                const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
                const compressed = await compressImage(dataUrl, 1200, 0.75);
                const newImages = [...scannerCapturedImages, compressed];
                setScannerCapturedImages(newImages);

                if (newImages.length >= 2) {
                    // Have both front and back â€” stop camera and recognize
                    stopScannerCamera();
                    setUploadedImages(newImages);
                    recognizeCard(newImages);
                }
            };

            const submitScannerImages = () => {
                if (scannerCapturedImages.length === 0) return;
                stopScannerCamera();
                setUploadedImages(scannerCapturedImages);
                recognizeCard(scannerCapturedImages);
            };

            const removeScannerImage = (index) => {
                setScannerCapturedImages(prev => prev.filter((_, i) => i !== index));
            };

            // Callback ref to attach stream as soon as video element mounts
            const scannerVideoCallbackRef = React.useCallback((node) => {
                scannerVideoRef.current = node;
                if (node && scannerCameraStream) {
                    node.srcObject = scannerCameraStream;
                }
            }, [scannerCameraStream]);

            // Stop camera when scanner modal closes
            React.useEffect(() => {
                if (!showImageUpload && scannerCameraActive) {
                    stopScannerCamera();
                    setScannerCapturedImages([]);
                    setScannerMode('camera');
                }
            }, [showImageUpload]);

            const handleImageUpload = async (event) => {
                const files = Array.from(event.target.files);
                if (files.length === 0) return;
                
                // Limit to 2 images (front and back)
                const filesToProcess = files.slice(0, 2);
                if (files.length > 2) {
                    alert(`ðŸ“¸ Multiple Images Selected\n\nProcessing first 2 images (front and back of card).\n\nTip: Upload front and back for best recognition accuracy!`);
                }
                
                setDeepAnalysis(null);
                setSelectedAnalysisSource('opus');
                setIsRecognizing(true);
                
                const processedImages = [];
                
                for (let file of filesToProcess) {
                    try {
                        // Check if file is HEIC/HEIF
                        const isHEIC = file.type === 'image/heic' || 
                                       file.type === 'image/heif' || 
                                       file.name.toLowerCase().endsWith('.heic') || 
                                       file.name.toLowerCase().endsWith('.heif');
                        
                        if (isHEIC) {
                            // Convert HEIC to JPEG automatically
                            try {
                                console.log(`Converting HEIC file: ${file.name}`);
                                
                                // Check if heic2any library is loaded
                                if (typeof window.heic2any === 'undefined') {
                                    throw new Error('heic2any library not loaded. Please refresh the page.');
                                }
                                
                                const convertedBlob = await window.heic2any({
                                    blob: file,
                                    toType: 'image/jpeg',
                                    quality: 0.9
                                });
                                
                                // heic2any might return array of blobs
                                const blob = Array.isArray(convertedBlob) ? convertedBlob[0] : convertedBlob;
                                
                                // Create a new File object with JPEG type
                                file = new File([blob], file.name.replace(/\.heic$/i, '.jpg'), {
                                    type: 'image/jpeg'
                                });
                                
                                console.log(`âœ“ HEIC conversion successful: ${file.name}`);
                            } catch (conversionError) {
                                console.error('HEIC conversion error:', conversionError);
                                setIsRecognizing(false);
                                
                                // Provide helpful error message based on error type
                                let errorDetail = conversionError.message || 'Unknown error';
                                let suggestion = '';
                                
                                if (errorDetail.includes('format not supported')) {
                                    suggestion = '\n\nðŸ’¡ This HEIC file uses a format variant that cannot be converted automatically.\n\n';
                                } else if (errorDetail.includes('library not loaded')) {
                                    suggestion = '\n\nðŸ’¡ Please refresh the page and try again.\n\n';
                                } else {
                                    suggestion = '\n\n';
                                }
                                
                                alert(`ðŸ“± Cannot Auto-Convert HEIC File\n\nFile: ${file.name}${suggestion}QUICK FIX - Use iPhone Screenshot:\n\n1ï¸âƒ£ Open the photo in Photos app\n2ï¸âƒ£ Take a SCREENSHOT of the photo\n   (Press Side + Volume Up buttons)\n3ï¸âƒ£ Upload the screenshot instead\n   (Screenshots are JPG format!)\n\nOR Convert Manually:\n\n1ï¸âƒ£ Open Photos app\n2ï¸âƒ£ Select the photo\n3ï¸âƒ£ Tap Share (â¬†ï¸)\n4ï¸âƒ£ Scroll down â†’ "Save to Files"\n5ï¸âƒ£ Upload the converted file\n\nâœ¨ Screenshots work instantly!`);
                                event.target.value = '';
                                return;
                            }
                        }
                        
                        // Read file as data URL
                        const dataUrl = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(file);
                        });
                        
                        // Compress image to reduce size
                        console.log(`Compressing image ${filesToProcess.indexOf(file) + 1}/${filesToProcess.length}...`);
                        const compressed = await compressImage(dataUrl, 1200, 0.75);
                        processedImages.push(compressed);
                    } catch (error) {
                        console.error('Error processing file:', file.name, error);
                        setIsRecognizing(false);
                        alert(`Error processing image: ${file.name}\n\nPlease try a different file.`);
                        event.target.value = '';
                        return;
                    }
                }
                
                if (processedImages.length > 0) {
                    // Combine with existing pending images if adding a second image
                    const allImages = [...(showSecondImagePrompt ? pendingImages : uploadedImages || []), ...processedImages];
                    
                    if (allImages.length === 1) {
                        // Still only 1 image - show prompt again
                        setPendingImages(allImages);
                        setShowSecondImagePrompt(true);
                        setIsRecognizing(false);
                    } else if (allImages.length >= 2) {
                        // 2 or more images - close prompt and proceed with analysis
                        setShowSecondImagePrompt(false);
                        setPendingImages([]);
                        setUploadedImages(allImages);
                        recognizeCard(allImages);
                    }
                } else {
                    setIsRecognizing(false);
                    event.target.value = '';
                }
            };

            const recognizeCard = async (base64Images) => {
                setIsRecognizing(true);
                setRecognizedCard(null);
                setRecognitionError(null);
                setSelectedAnalysisSource('opus');

                try {
                    // Handle both single image and array
                    const images = Array.isArray(base64Images) ? base64Images : [base64Images];
                    
                    // Build content array with images
                    const contentArray = [];
                    
                    images.forEach((base64Image, index) => {
                        const mediaTypeMatch = base64Image.match(/^data:(image\/[a-zA-Z]+);base64,/);
                        const mediaType = mediaTypeMatch ? mediaTypeMatch[1] : 'image/jpeg';
                        const imageData = base64Image.split(',')[1];
                        
                        contentArray.push({
                            type: "image",
                            source: { type: "base64", media_type: mediaType, data: imageData }
                        });
                    });
                    
                    // Add text prompt after images
                    const promptText = images.length > 1 
                        ? `Analyze these F1 trading card images (FRONT and BACK of the same card). 

CRITICAL: 
- Image 1: Front of card (driver photo)
- Image 2: Back of card (contains CARD NUMBER)

The BACK IMAGE is ESSENTIAL - extract the card number from it very carefully!`
                        : `Analyze this F1 trading card image.`;
                    
                    contentArray.push({
                        type: "text",
                        text: `${promptText}

CARD SET CONTEXT:
2025 Topps Chrome Formula 1 set. Treat all cards as 2025 edition even if imagery appears older.

CRITICAL - CARD NUMBER EXTRACTION (FROM BACK IMAGE):
${images.length > 1 ? `The BACK IMAGE contains the card number - extract it VERY carefully! Look for:
  â€¢ Small card number in bottom left or elsewhere on back
  â€¢ Format examples: "#1", "#42", "R-1", "CR-15", etc.
  â€¢ This is NOT the gold serial number (e.g., "63/299")
  â€¢ Back image card number guides analysis for accurate details` : 'Extract the card number from the card'}

TASK: Analyze this card thoroughly with web search for current market values.

Web Search Strategy:
1. Use card number to search for exact 2025 Topps Chrome F1 card listings
2. Find real eBay, Cardmarket, or PSA sales data for this specific card
3. Look for current market prices in Raw, PSA 9, and PSA 10 conditions
4. Use the card number to find accurate pricing data

Analyze this card THOROUGHLY with detailed structure using web search results for value estimates.

IMPORTANT: Return ONLY valid JSON with properly escaped newlines (use \\n for line breaks, not actual newlines). No markdown, no extra text.

{
  "cardNumber": "from back image if visible, else inferred",
  "cardNumberConfidence": "high/medium/low",
  "cardNumberSource": "${images.length > 1 ? 'back_image/front_image/inferred' : 'front_image/inferred'}",
  "serialNumber": "null or serial like 63/250",
  "driverName": "full name",
  "team": "full team",
  "subset": "subset name",
  "variant": "exact variant name",
  "isRookie": true or false,
  "confidence": "high/medium/low",
  "analysis": "CARD IDENTIFICATION:\\n[Driver name, team, card number verification, visual details]\\n\\nVARIANT & RARITY:\\n[Specific variant analysis, serial number details if present]\\n\\nVALUE ESTIMATES (2025 Topps Chrome F1 - from web search):\\nRaw: $X-Y\\nPSA 9: $X-Y\\nPSA 10: $X-Y\\n\\nVALUE SOURCES & DERIVATION:\\n[Weight most heavily: sales of this EXACT card (year, driver/card #, subset, variant)]\\n[Then: same driver different variants, then similar cards in set]\\n[List 1-3 credible sources with comparable sales data]\\n[Include: eBay recent sales (e.g. 3 sold $5-8 Feb 2025), PSA guide ($X-Y), TCGPlayer listings]\\n[Show specific comparable: Card #XXX sold for $Y on [Date]]\\n[Calculation: Average of X comparable sales]\\nExample: 'eBay: 5 Base cards $5-8 avg (Feb), PSA guide $7-10, TCGPlayer $6-9. #161 Base up 15% due to rookie demand'\\n\\nCOLLECTIBILITY:\\n[Why collectors want this card, current market trends]"
}`
                    });
                    
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: getAuthHeaders(),
                        body: JSON.stringify({
                            model: "claude-opus-4-5-20251101",
                            max_tokens: 3000,
                            tools: [{
                                type: "web_search_20250305",
                                name: "web_search"
                            }],
                            messages: [{
                                role: "user",
                                content: contentArray
                            }]
                        })
                    });

                    const data = await response.json();

                    // Log response structure for debugging
                    console.log('Recognition API response status:', response.status);
                    console.log('Recognition response blocks:', data.content?.length || 0, 'stop_reason:', data.stop_reason);
                    if (data.error) {
                        console.error('API error:', data.error);
                        throw new Error(data.error.message || 'API returned an error');
                    }

                    // Extract text from all content blocks (handle tool_use blocks before text)
                    if (data.content && data.content.length > 0) {
                        let fullText = data.content
                            .filter(block => block.type === 'text')
                            .map(block => block.text)
                            .join('\n\n')
                            .trim();

                        if (!fullText) {
                            console.error('No text blocks in response. Block types:', data.content.map(b => b.type));
                            throw new Error('No text content in API response');
                        }
                        
                        // Remove markdown code blocks
                        fullText = fullText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                        
                        console.log('Opus response length:', fullText.length);
                        
                        // Strategy: Extract the analysis field first (which can contain newlines)
                        let recognized = {};
                        let analysisText = null;
                        
                        // Extract analysis field - handle newlines in the value
                        const analysisMatch = fullText.match(/"analysis":\s*"([\s\S]*?)"\s*(?:}|,)/);
                        if (analysisMatch && analysisMatch[1]) {
                            analysisText = analysisMatch[1]
                                .replace(/\\n/g, '\n')  // Convert escaped newlines to actual newlines
                                .trim();
                            console.log('âœ“ Extracted analysis text, length:', analysisText.length);
                        }
                        
                        // Now try to extract the JSON object for other fields
                        let jsonMatch = fullText.match(/\{[\s\S]*\}(?=\s*$)/);
                        if (!jsonMatch) {
                            const startIdx = fullText.indexOf('{');
                            const endIdx = fullText.lastIndexOf('}');
                            if (startIdx !== -1 && endIdx !== -1 && endIdx > startIdx) {
                                jsonMatch = [fullText.substring(startIdx, endIdx + 1)];
                            }
                        }
                        
                        if (jsonMatch && jsonMatch[0]) {
                            try {
                                // Try to parse the full JSON first
                                recognized = JSON.parse(jsonMatch[0]);
                                console.log('âœ“ Successfully parsed full Opus response');
                            } catch (parseError) {
                                console.warn('Full JSON parse failed, attempting field extraction:', parseError.message);
                                
                                // Fallback: extract individual fields using regex
                                const cardNumberMatch = fullText.match(/"cardNumber":\s*"([^"]*)"/);
                                const confMatch = fullText.match(/"cardNumberConfidence":\s*"([^"]*)"/);
                                const sourceMatch = fullText.match(/"cardNumberSource":\s*"([^"]*)"/);
                                const driverMatch = fullText.match(/"driverName":\s*"([^"]*)"/);
                                const teamMatch = fullText.match(/"team":\s*"([^"]*)"/);
                                const subsetMatch = fullText.match(/"subset":\s*"([^"]*)"/);
                                const variantMatch = fullText.match(/"variant":\s*"([^"]*)"/);
                                const serialMatch = fullText.match(/"serialNumber":\s*(?:null|"([^"]*)")/);
                                const rookieMatch = fullText.match(/"isRookie":\s*(true|false)/);
                                
                                recognized = {
                                    cardNumber: cardNumberMatch?.[1] || 'Unknown',
                                    cardNumberConfidence: confMatch?.[1] || 'medium',
                                    cardNumberSource: sourceMatch?.[1] || 'inferred',
                                    driverName: driverMatch?.[1] || 'Unknown',
                                    team: teamMatch?.[1] || 'Unknown',
                                    subset: subsetMatch?.[1] || 'Unknown',
                                    variant: variantMatch?.[1] || 'Base',
                                    serialNumber: serialMatch?.[1] || null,
                                    isRookie: rookieMatch?.[1] === 'true'
                                };
                                console.log('âœ“ Extracted fields via regex');
                            }
                        } else {
                            console.warn('No JSON structure found in response');
                        }
                        
                        // Validate/infer variant from serial number if present
                        if (recognized.serialNumber) {
                            const inferredVariants = inferVariantFromSerial(recognized.serialNumber);
                            if (inferredVariants) {
                                const originalVariant = recognized.variant;
                                recognized.variant = validateVariantWithSerial(recognized.variant, recognized.serialNumber);
                                if (originalVariant !== recognized.variant) {
                                    console.log(`ðŸ“Š Serial number /${recognized.serialNumber} corrected variant from "${originalVariant}" to "${recognized.variant}"`);
                                } else {
                                    console.log(`âœ“ Serial number /${recognized.serialNumber} confirms variant: ${recognized.variant}`);
                                }
                            }
                        }
                        
                        // Use the extracted analysis text if available
                        if (analysisText) {
                            recognized.analysis = analysisText;
                        }
                        
                        if (recognized && recognized.analysis) {
                            setRecognizedCard(recognized);
                            console.log('âœ“ Card recognized with analysis');
                        } else {
                            throw new Error('Could not extract analysis from response');
                        }
                    } else {
                        throw new Error('Invalid response from API');
                    }
                } catch (error) {
                    console.error('Recognition error:', error);
                    setRecognitionError(error.message || 'Failed to recognize card');
                } finally {
                    setIsRecognizing(false);
                }
            };

            const performQuickGrade = async () => {
                if (!uploadedImages || uploadedImages.length === 0) {
                    alert('Please upload an image before grading.');
                    return;
                }

                setIsDeepAnalyzing(true);
                try {
                    const gradingPrompt = `You are an expert trading card grader analyzing 2025 Topps Chrome Formula 1 cards for potential PSA grading.

IMPORTANT - PROTECTIVE CONTAINERS:
If the card is in a penny sleeve, toploader, or other protective sleeve:
- Assess the card condition THROUGH the protective sleeve
- Make best effort to evaluate the card itself, not the container
- Note in the assessment that protective container was present
- Do NOT penalize the card for being in protective sleeve (it's standard practice)
- Assess the visible portions of the card condition

ANALYZE ALL PROVIDED IMAGES FOR COMPLETE ASSESSMENT:
Look at front, back, and any detail shots to form comprehensive evaluation.

ASSESSMENT CRITERIA:
Centering: left/right and top/bottom border ratios (55/45 or better = 10 potential)
Surface: scratches, print lines, dimples, roller marks, gloss uniformity
Corners: all four corners front/back for whitening, rounding, chipping
Edges: whitening, rough cuts, micro-chips
Print Quality: blur, misregistration, shadow text, color issues
Gloss & Cleanliness: uniformity, fingerprints, dust
Foil/Numbering: indentation, flaking, clarity

PROVIDE ASSESSMENT IN THIS FORMAT:

FINAL ASSESSMENT
[Driver/Card]: [Overall condition summary in 1-2 sentences]
Estimated PSA Grade: [X] with [Y]% confidence
Recommended for grading: Yes/No (only if 8+ probability)

GRADE PROBABILITY
PSA 10: [X]%
PSA 9: [X]%
PSA 8: [X]%
PSA 7 or below: [X]%

CONDITION CHECKLIST
Centering: [PASS/FAIL]
Surface: [PASS/FAIL]
Corners: [PASS/FAIL]
Edges: [PASS/FAIL]
Foil/Stamp: [PASS/FAIL]

DETAILED ANALYSIS
Centering: [Assessment]
Surface: [Findings]
Corners: [All 4 corners evaluation]
Edges: [Edge condition]
Print Quality: [Observations]
Gloss & Cleanliness: [Assessment]
Foil/Numbering: [Condition]

NOTES:
[Any protective sleeves detected, handling marks, or other observations]

GRADING SCALE FOR 2025 TOPPS CHROME F1:
- 5/5 checklist PASS = PSA 10 (90%+ confidence)
- 4/5 checklist PASS = PSA 9 (60-80% confidence)
- 3/5 checklist PASS = PSA 8-9 (40-60% confidence)
- 2/5 or less = PSA 8 or below

KEY FACTORS:
- Centering is primary PSA 9 vs 10 differentiator
- Any surface flaw = PSA 9 ceiling
- Chrome susceptibility to damage is factor
- Protective sleeve does NOT reduce grade`;

                    // Build content array with all images
                    const contentArray = [];
                    
                    // Add all uploaded images
                    uploadedImages.forEach((img, idx) => {
                        const imageBase64 = img.split(',')[1];
                        contentArray.push({
                            type: 'image',
                            source: {
                                type: 'base64',
                                media_type: 'image/jpeg',
                                data: imageBase64
                            }
                        });
                    });
                    
                    // Add the grading prompt
                    contentArray.push({
                        type: 'text',
                        text: gradingPrompt
                    });

                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: getAuthHeaders(),
                        body: JSON.stringify({
                            model: 'claude-opus-4-5-20251101',
                            max_tokens: 2000,
                            messages: [{
                                role: 'user',
                                content: contentArray
                            }]
                        })
                    });

                    const data = await response.json();
                    console.log('Grade API Response:', data);
                    
                    if (data.content && data.content.length > 0) {
                        const gradeReport = data.content
                            .filter(block => block.type === 'text')
                            .map(block => block.text)
                            .join('\n\n');
                        
                        console.log('Grade Report Generated:', gradeReport.substring(0, 200));
                        
                        if (recognizedCard) {
                            setRecognizedCard(prev => ({
                                ...prev,
                                gradeReport: gradeReport
                            }));
                            
                            // Create custom alert that scrolls to QGA
                            if (window.confirm('âœ… Grade Report Generated!\n\nClick OK to view the Quick Grade Assessment.')) {
                                // Scroll to the Quick Grade Assessment section
                                setTimeout(() => {
                                    const qgaElement = document.querySelector('[data-testid="quick-grade-assessment"]') || 
                                                      document.querySelector('.bg-blue-900\\/20') ||
                                                      Array.from(document.querySelectorAll('*')).find(el => 
                                                          el.textContent && el.textContent.includes('Quick Grade Assessment'));
                                    
                                    if (qgaElement) {
                                        qgaElement.scrollIntoView({ 
                                            behavior: 'smooth', 
                                            block: 'center',
                                            inline: 'nearest'
                                        });
                                        // Add a subtle highlight effect
                                        qgaElement.style.boxShadow = '0 0 20px rgba(59, 130, 246, 0.5)';
                                        setTimeout(() => {
                                            qgaElement.style.boxShadow = '';
                                        }, 2000);
                                    }
                                }, 500);
                            }
                        } else {
                            console.warn('recognizedCard not set, cannot store grade report');
                            alert('âš ï¸ Grade report created but card not recognized. Please ensure card is analyzed first.');
                        }
                    } else {
                        alert('âŒ No response from grading API');
                    }
                } catch (error) {
                    console.error('Grade analysis error:', error);
                    alert('âŒ Error generating grade report:\n' + error.message);
                } finally {
                    setIsDeepAnalyzing(false);
                }
            };

            // Quick grade function for individual variants in card detail view
            const performQuickGradeForVariant = async (cardNum, variant) => {
                if (!uploadedImages || uploadedImages.length === 0) {
                    alert('Please upload an image before grading this variant.');
                    return;
                }

                try {
                    const gradingPrompt = `You are an expert trading card grader analyzing 2025 Topps Chrome Formula 1 cards for potential PSA grading.

IMPORTANT - PROTECTIVE CONTAINERS:
Cards in protective containers (sleeves, toploaders, magnetic holders, etc.) can still be accurately assessed. Focus on visible card condition through the protection.

Please provide a detailed grading assessment for this ${variant} card #${cardNum} with these sections:

FINAL ASSESSMENT
- Overall condition summary
- Estimated PSA grade with confidence level
- Key factors affecting grade

GRADE PROBABILITY
- PSA 10: X% (probability)  
- PSA 9: X% (probability)
- PSA 8: X% (probability)
- Lower: X% (probability)

CONDITION CHECKLIST
- Centering: PASS/FAIL (detailed assessment)
- Corners: PASS/FAIL (detailed assessment)  
- Edges: PASS/FAIL (detailed assessment)
- Surface: PASS/FAIL (detailed assessment)

DETAILED ANALYSIS
- Specific observations about flaws or positive aspects
- Impact of any protective casing on assessment
- Recommendations for grading submission

Be thorough and specific in your assessment.`;

                    // Build content array with all images
                    const contentArray = [];
                    
                    uploadedImages.forEach((uploadedImage) => {
                        contentArray.push({
                            type: 'image',
                            source: {
                                type: 'base64',
                                media_type: 'image/jpeg',
                                data: uploadedImage.split(',')[1]
                            }
                        });
                    });

                    contentArray.push({
                        type: 'text',
                        text: gradingPrompt
                    });

                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: getAuthHeaders(),
                        body: JSON.stringify({
                            model: 'claude-opus-4-5-20251101',
                            max_tokens: 2000,
                            messages: [{
                                role: 'user',
                                content: contentArray
                            }]
                        })
                    });

                    const data = await response.json();
                    
                    if (data.content && data.content.length > 0) {
                        const gradeReport = data.content
                            .filter(block => block.type === 'text')
                            .map(block => block.text)
                            .join('\n\n');
                        
                        // Save the grade report for this specific variant
                        const key = getCardKey(cardNum);
                        const updatedCollection = { ...collection };
                        
                        if (!updatedCollection[key]) updatedCollection[key] = {};
                        if (!updatedCollection[key]._gradeReports) updatedCollection[key]._gradeReports = {};
                        
                        updatedCollection[key]._gradeReports[variant] = gradeReport;
                        
                        setCollection(updatedCollection);
                        saveCollection(updatedCollection);
                        
                    } else {
                        console.error('QGA: No response from grading API');
                    }
                } catch (error) {
                    console.error('QGA: Quick grade error for variant:', error);
                    setRecognitionError('Failed to grade card variant. Please try again.');
                }
            };

            // Grade a variant using provided images (from camera modal)
            const performGradeWithImages = async (cardNum, variant, images) => {
                if (!images || images.length === 0) return;

                const analyzeKey = `${cardNum}-${variant}`;
                setAnalyzingCards(prev => ({ ...prev, [analyzeKey]: true }));

                try {
                    const gradingPrompt = `You are an expert trading card grader analyzing 2025 Topps Chrome Formula 1 cards for potential PSA grading.

IMPORTANT - PROTECTIVE CONTAINERS:
Cards in protective containers (sleeves, toploaders, magnetic holders, etc.) can still be accurately assessed. Focus on visible card condition through the protection.

Please provide a detailed grading assessment for this ${variant} card #${cardNum} with these sections:

FINAL ASSESSMENT
- Overall condition summary
- Estimated PSA grade with confidence level
- Key factors affecting grade

GRADE PROBABILITY
- PSA 10: X% (probability)
- PSA 9: X% (probability)
- PSA 8: X% (probability)
- Lower: X% (probability)

CONDITION CHECKLIST
- Centering: PASS/FAIL (detailed assessment)
- Corners: PASS/FAIL (detailed assessment)
- Edges: PASS/FAIL (detailed assessment)
- Surface: PASS/FAIL (detailed assessment)

DETAILED ANALYSIS
- Specific observations about flaws or positive aspects
- Impact of any protective casing on assessment
- Recommendations for grading submission

Be thorough and specific in your assessment.`;

                    const contentArray = [];
                    images.forEach((img) => {
                        contentArray.push({
                            type: 'image',
                            source: {
                                type: 'base64',
                                media_type: 'image/jpeg',
                                data: img.split(',')[1]
                            }
                        });
                    });
                    contentArray.push({ type: 'text', text: gradingPrompt });

                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: getAuthHeaders(),
                        body: JSON.stringify({
                            model: 'claude-opus-4-5-20251101',
                            max_tokens: 2000,
                            messages: [{ role: 'user', content: contentArray }]
                        })
                    });

                    const data = await response.json();
                    if (data.content && data.content.length > 0) {
                        const gradeReport = data.content
                            .filter(block => block.type === 'text')
                            .map(block => block.text)
                            .join('\n\n');

                        const key = getCardKey(cardNum);
                        setCollection(prev => {
                            const updated = JSON.parse(JSON.stringify(prev));
                            if (!updated[key]) updated[key] = {};
                            if (!updated[key]._gradeReports) updated[key]._gradeReports = {};
                            updated[key]._gradeReports[variant] = gradeReport;
                            localStorage.setItem('f1-collection-pro-v2', JSON.stringify(updated));
                            const mongoData = stripMetadataForMongo(updated);
                            fetch(`https://f1-card-tracker-backend-1.onrender.com/api/collection/cincymed-f1-collection`, {
                                method: 'POST',
                                headers: getAuthHeaders(),
                                body: JSON.stringify({ cards: mongoData })
                            }).catch(err => console.error('MongoDB sync error:', err));
                            return updated;
                        });
                    }
                } catch (error) {
                    console.error('Grade with images error:', error);
                } finally {
                    setAnalyzingCards(prev => {
                        const updated = { ...prev };
                        delete updated[analyzeKey];
                        return updated;
                    });
                }
            };

            const performDeepAnalysis = async () => {
                if (!uploadedImages || uploadedImages.length === 0 || !recognizedCard) return;
                
                setIsDeepAnalyzing(true);
                setDeepAnalysis(null);

                try {
                    // Build content array with all images
                    const contentArray = [];
                    
                    uploadedImages.forEach((uploadedImage) => {
                        const mediaTypeMatch = uploadedImage.match(/^data:(image\/[a-zA-Z]+);base64,/);
                        const mediaType = mediaTypeMatch ? mediaTypeMatch[1] : 'image/jpeg';
                        const imageData = uploadedImage.split(',')[1];
                        
                        contentArray.push({
                            type: "image",
                            source: { type: "base64", media_type: mediaType, data: imageData }
                        });
                    });
                    
                    const promptText = uploadedImages.length > 1
                        ? `Perform DEEP analysis of these F1 card images (FRONT and BACK). The BACK image contains the card number which is KEY to accurate research.`
                        : `Perform DEEP analysis of this F1 card image.`;
                    
                    // Add text prompt
                    contentArray.push({
                        type: "text",
                        text: `${promptText}

CARD SET: 2025 Topps Chrome Formula 1 (treat all as 2025 regardless of imagery age)

Current Detection:
Card #${recognizedCard.cardNumber} (confidence: ${recognizedCard.cardNumberConfidence})
${recognizedCard.cardNumberSource ? `Source: ${recognizedCard.cardNumberSource}` : ''}
Driver: ${recognizedCard.driverName}
Team: ${recognizedCard.team}
Variant: ${recognizedCard.variant}
${recognizedCard.serialNumber ? `Serial: ${recognizedCard.serialNumber}` : ''}

TASK: Use the card number (especially from BACK IMAGE if available) to guide web search for accurate 2025 Topps Chrome F1 card details and current market values.

Web Search Strategy:
1. Use card number #${recognizedCard.cardNumber} as primary identifier
2. Search for "2025 Topps Chrome F1 card #${recognizedCard.cardNumber} ${recognizedCard.driverName}"
3. Find current market prices for this specific card and variant
4. Verify driver, team, rookie status, and subset from search results
5. Get accurate value ranges for Raw, PSA 9, PSA 10 conditions

IMPORTANT: Return ONLY valid JSON with properly escaped newlines (use \\n for line breaks, not actual newlines). No markdown, no extra text.

{
  "cardNumber": "verified via back image and web search",
  "cardNumberSource": "back_image/front_image/web_search/database",
  "serialNumber": "serial if visible, else null",
  "driverName": "full driver name",
  "team": "full team name",
  "subset": "subset category",
  "variant": "exact variant (Base, Refractor, Purple /299, Blue /150, Green /99, Gold /50, Orange /25, Red /5, SuperFractor 1/1, Black /10, Magenta /250, Gold Wave /75, Printing Plate 1/1)",
  "isRookie": true/false,
  "confidence": "high/medium/low",
  "analysis": "CARD IDENTIFICATION:\\n[Back image card number and driver verification]\\n\\nWEB SEARCH FINDINGS:\\n[2025 Topps Chrome F1 market data for this card and variant]\\n\\nVARIANT & RARITY:\\n[Specific variant analysis]\\n\\nVALUE ESTIMATES (2025 Topps Chrome F1):\\nRaw: $X-Y\\nPSA 9: $X-Y\\nPSA 10: $X-Y\\n\\nCOMPARABLE SALES:\\n1. #[card#] [variant] - $[price] on [date] ([source])\\n2. #[card#] [variant] - $[price] on [date] ([source])\\n3. #[card#] [variant] - $[price] on [date] ([source])\\n4. #[card#] [variant] - $[price] on [date] ([source])\\n5. #[card#] [variant] - $[price] on [date] ([source])\\n[List top 5 most pertinent sales sorted by closest match to card/variant then most recent date. Include card #, variant, sale price, date, and data source (eBay, PSA Price Guide, TCGPlayer, COMC, Beckett, 130point, etc.)]\\n\\nVALUE SOURCES & DERIVATION:\\n[Calculation: Average of X comparable sales]\\n\\nCOLLECTIBILITY:\\n[Why collectors want this, market trends]"
}`
                    });
                    
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: getAuthHeaders(),
                        body: JSON.stringify({
                            model: "claude-sonnet-4-5-20250929",
                            max_tokens: 4000,
                            tools: [{
                                type: "web_search_20250305",
                                name: "web_search"
                            }],
                            messages: [{
                                role: "user",
                                content: contentArray
                            }]
                        })
                    });

                    const data = await response.json();
                    
                    if (data.content) {
                        console.log('Opus response blocks:', data.content.length);
                        
                        // Extract all text content blocks (may include web search results)
                        let fullText = data.content
                            .filter(block => block.type === 'text')
                            .map(block => block.text)
                            .join('\n\n')
                            .trim();
                        
                        console.log('Extracted text length:', fullText.length);
                        console.log('First 500 chars:', fullText.substring(0, 500));
                        
                        // Remove markdown code blocks
                        fullText = fullText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                        
                        // Strategy: Extract the analysis field first (which can contain newlines)
                        // Then extract other fields from JSON
                        let opusData = {};
                        let analysisText = null;
                        
                        // Extract analysis field - handle newlines in the value
                        const analysisMatch = fullText.match(/"analysis":\s*"([\s\S]*?)"\s*(?:}|,)/);
                        if (analysisMatch && analysisMatch[1]) {
                            analysisText = analysisMatch[1]
                                .replace(/\\n/g, '\n')  // Convert escaped newlines to actual newlines
                                .trim();
                            console.log('âœ“ Extracted analysis text, length:', analysisText.length);
                        }
                        
                        // Now try to extract the JSON object for other fields
                        let jsonMatch = fullText.match(/\{[\s\S]*\}(?=\s*$)/);
                        if (!jsonMatch) {
                            const startIdx = fullText.indexOf('{');
                            const endIdx = fullText.lastIndexOf('}');
                            if (startIdx !== -1 && endIdx !== -1 && endIdx > startIdx) {
                                jsonMatch = [fullText.substring(startIdx, endIdx + 1)];
                            }
                        }
                        
                        if (jsonMatch && jsonMatch[0]) {
                            try {
                                // Try to parse the full JSON first
                                opusData = JSON.parse(jsonMatch[0]);
                                console.log('âœ“ Successfully parsed full Opus JSON response');
                            } catch (parseError) {
                                console.warn('Full JSON parse failed, attempting field extraction:', parseError.message);
                                
                                // Fallback: extract individual fields using regex
                                const cardNumberMatch = fullText.match(/"cardNumber":\s*"([^"]*)"/);
                                const driverMatch = fullText.match(/"driverName":\s*"([^"]*)"/);
                                const teamMatch = fullText.match(/"team":\s*"([^"]*)"/);
                                const subsetMatch = fullText.match(/"subset":\s*"([^"]*)"/);
                                const variantMatch = fullText.match(/"variant":\s*"([^"]*)"/);
                                const serialMatch = fullText.match(/"serialNumber":\s*(?:null|"([^"]*)")/);
                                const rookieMatch = fullText.match(/"isRookie":\s*(true|false)/);
                                const confMatch = fullText.match(/"confidence":\s*"([^"]*)"/);
                                
                                opusData = {
                                    cardNumber: cardNumberMatch?.[1] || 'Unknown',
                                    driverName: driverMatch?.[1] || 'Unknown',
                                    team: teamMatch?.[1] || 'Unknown',
                                    subset: subsetMatch?.[1] || 'Unknown',
                                    variant: variantMatch?.[1] || 'Base',
                                    serialNumber: serialMatch?.[1] || null,
                                    isRookie: rookieMatch?.[1] === 'true',
                                    confidence: confMatch?.[1] || 'medium'
                                };
                                console.log('âœ“ Extracted fields via regex:', Object.keys(opusData));
                            }
                        } else {
                            console.warn('No JSON structure found in response');
                        }
                        
                        // Validate/infer variant from serial number if present
                        if (opusData.serialNumber) {
                            const inferredVariants = inferVariantFromSerial(opusData.serialNumber);
                            if (inferredVariants) {
                                const originalVariant = opusData.variant;
                                opusData.variant = validateVariantWithSerial(opusData.variant, opusData.serialNumber);
                                if (originalVariant !== opusData.variant) {
                                    console.log(`ðŸ“Š Serial number /${opusData.serialNumber} corrected variant from "${originalVariant}" to "${opusData.variant}"`);
                                } else {
                                    console.log(`âœ“ Serial number /${opusData.serialNumber} confirms variant: ${opusData.variant}`);
                                }
                            }
                        }
                        
                        // Use the extracted analysis text if available
                        if (analysisText) {
                            opusData.analysis = analysisText;
                        }
                        
                        if (opusData && opusData.analysis) {
                            // Successfully parsed - set ONLY the analysis field
                            setDeepAnalysis(opusData.analysis);
                            
                            // Update card with Opus findings
                            const updatedCard = {
                                ...recognizedCard,
                                cardNumber: manualCardNumber || opusData.cardNumber,
                                _opusData: opusData,
                                _differences: {
                                    cardNumber: manualCardNumber ? false : (opusData.cardNumber !== recognizedCard.cardNumber),
                                    serialNumber: opusData.serialNumber !== recognizedCard.serialNumber,
                                    driverName: opusData.driverName !== recognizedCard.driverName,
                                    team: opusData.team !== recognizedCard.team,
                                    subset: opusData.subset !== recognizedCard.subset,
                                    variant: opusData.variant !== recognizedCard.variant
                                }
                            };
                            
                            setRecognizedCard(updatedCard);
                            console.log('âœ“ Deep analysis complete');
                        } else {
                            // Could not parse or extract analysis
                            console.error('Could not extract analysis from Opus response');
                            console.error('opusData:', opusData);
                            console.error('Has analysis field:', opusData?.analysis ? 'yes' : 'no');
                            setDeepAnalysis('Error: Could not extract analysis. Please try again or check server logs.');
                        }
                    } else {
                        throw new Error('Invalid response from API - no content blocks');
                    }
                } catch (error) {
                    console.error('Deep analysis error:', error);
                    setDeepAnalysis('Error performing deep analysis. Please try again.');
                } finally {
                    setIsDeepAnalyzing(false);
                }
            };

            const handleDoneEditing = () => {
                setRecognizedCard(editedCard);
                setIsEditing(false);
            };

            const handleAddRecognizedCard = () => {
                if (recognizedCard) {
                    try {
                        // Use the selected analysis source
                        const analysisToUse = selectedAnalysisSource === 'opus' && deepAnalysis 
                            ? deepAnalysis 
                            : recognizedCard.analysis;
                        
                        let aiVariant = recognizedCard.variant;
                        if (aiVariant === "Base Chrome") aiVariant = "Base";
                        
                        // Validate variant against official list
                        const validVariant = findBestVariantMatch(aiVariant);
                        
                        if (validVariant) {
                            // Good match found - proceed with adding
                            console.log(`Variant validated: "${aiVariant}" â†’ "${validVariant}"`);
                            addCardWithVariant(recognizedCard.cardNumber, validVariant, analysisToUse);
                        } else {
                            // No good match - show user a selection modal
                            console.warn(`âš ï¸ Unknown variant: "${aiVariant}" - asking user to select`);
                            setVariantValidationModal({
                                cardNum: recognizedCard.cardNumber,
                                aiVariant: aiVariant,
                                pendingAnalysis: analysisToUse
                            });
                            return; // Don't close scanner yet
                        }
                    } catch (error) {
                        console.error('Error adding card:', error);
                        alert('âŒ Error adding card: ' + error.message);
                    }
                }
            };

            // Helper function to add card after variant is confirmed
            const addCardWithVariant = (cardNum, variant, analysis) => {
                console.log(`Adding card: #${cardNum} (${variant})`);
                
                // Pass gradeReport if it exists on recognizedCard
                const gradeReport = recognizedCard?.gradeReport || null;
                addCard(cardNum, variant, analysis, gradeReport);
                
                // Get card title from cardData
                const card = cardData.find(c => c.num === cardNum);
                const cardTitle = card ? card.name || card.driver || 'Unknown' : 'Unknown';
                
                // Get collection stats using the proper count function
                const jsonStr = JSON.stringify(collection);
                const totalCards = getTotalCollectionCount();
                
                // Show enhanced confirmation alert
                alert(`âœ… Added: Card #${cardNum}
${cardTitle}
Variant: ${variant}

ðŸ“¦ Collection Updated!
Total Cards: ${totalCards}
Storage: ${(jsonStr.length / 1024).toFixed(1)}KB`);
                
                // Set 5-second cooldown to prevent rate limit errors
                setAddCardCooldown(5);
                const cooldownInterval = setInterval(() => {
                    setAddCardCooldown(prev => {
                        if (prev <= 1) {
                            clearInterval(cooldownInterval);
                            return 0;
                        }
                        return prev - 1;
                    });
                }, 1000);
                
                setShowImageUpload(false);
                setUploadedImages([]);
                setPendingImages([]);
                setShowSecondImagePrompt(false);
                setRecognizedCard(null);
                setEditedCard(null);
                setIsEditing(false);
                setRecognitionError(null);
                setDeepAnalysis(null);
                setSelectedAnalysisSource('opus'); // Reset to default
                setVariantValidationModal(null);
                setScannerCapturedImages([]);
            };

            const handleLogout = () => {
                if (confirm('Are you sure you want to logout?')) {
                    localStorage.removeItem('f1-token');
                    localStorage.removeItem('f1-email');
                    window.location.href = 'login.html';
                }
            };

            const forceReloadCollection = async () => {
                try {
                    console.log('Starting force reload...');
                    
                    // Try MongoDB first with short timeout
                    try {
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
                        
                        const response = await fetch(`https://f1-card-tracker-backend-1.onrender.com/api/collection/cincymed-f1-collection`, {
                            method: 'GET',
                            headers: getAuthHeaders(),
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);
                        
                        if (response.ok) {
                            const data = await response.json();
                            if (data.cards && Object.keys(data.cards).length > 0) {
                                // Merge with local so analyses/grade reports aren't lost
                                const localRaw = localStorage.getItem('f1-collection-pro-v2');
                                const localColl = localRaw ? JSON.parse(localRaw) : {};
                                const merged = mergeMongoWithLocal(data.cards, localColl);
                                setCollection(merged);
                                localStorage.setItem('f1-collection-pro-v2', JSON.stringify(merged));
                                const cardCount = Object.keys(merged).filter(k => k.startsWith('card-')).length;
                                alert(`âœ… Synced from MongoDB!\n${cardCount} cards loaded`);
                                console.log('âœ… Successfully synced from MongoDB');
                                return;
                            }
                        }
                    } catch (mongoError) {
                        console.log('MongoDB sync failed, using localStorage:', mongoError.message);
                    }
                    
                    // Fallback to localStorage
                    const saved = localStorage.getItem('f1-collection-pro-v2');
                    if (saved) {
                        const collection = JSON.parse(saved);
                        setCollection(collection);
                        const cardCount = Object.keys(collection).filter(k => k.startsWith('card-')).length;
                        alert(`ðŸ“± Reloaded from local storage!\n${cardCount} cards found`);
                        console.log('âœ… Reloaded from localStorage');
                    } else {
                        alert('âš ï¸ No collection found in storage');
                    }
                } catch (error) {
                    console.error('Force reload error:', error);
                    alert('âŒ Error reloading collection');
                }
                setShowMenuDropdown(false);
            };

            // Force-push whatever is in this device's localStorage to MongoDB.
            // Use this on mobile when a card was scanned but didn't sync to the cloud.
            const forcePushToCloud = async () => {
                setShowMenuDropdown(false);
                const localRaw = localStorage.getItem('f1-collection-pro-v2');
                if (!localRaw) {
                    alert('âŒ No local collection found to push.');
                    return;
                }
                try {
                    const localColl = JSON.parse(localRaw);
                    const cleaned = cleanupCollection(localColl);

                    // Send counts-only â€” no analyses or grade reports.
                    // Analyses live in each device's localStorage and are preserved by
                    // mergeMongoWithLocal on the receiving device, so they don't need to
                    // travel through MongoDB. Counts-only keeps the payload tiny and
                    // avoids the 500 caused by oversized documents.
                    const countsOnly = {};
                    Object.keys(cleaned).forEach(cardKey => {
                        if (cardKey.startsWith('_')) return;
                        const card = cleaned[cardKey];
                        const counts = {};
                        Object.keys(card).forEach(k => {
                            if (!k.startsWith('_') && card[k] > 0) counts[k] = card[k];
                        });
                        if (Object.keys(counts).length > 0) countsOnly[cardKey] = counts;
                    });

                    const cardCount = Object.keys(countsOnly).length;
                    const payloadBytes = JSON.stringify({ cards: countsOnly }).length;
                    console.log(`Push to cloud (counts-only): ${cardCount} cards, ${(payloadBytes/1024).toFixed(1)}KB`);

                    const res = await fetch(
                        'https://f1-card-tracker-backend-1.onrender.com/api/collection/cincymed-f1-collection',
                        { method: 'POST', headers: getAuthHeaders(), body: JSON.stringify({ cards: countsOnly }) }
                    );
                    if (res.ok) {
                        alert(`â˜ï¸ Pushed to cloud!\n${cardCount} cards synced (${(payloadBytes/1024).toFixed(1)}KB).\n\nDesktop will pick up changes within 60 seconds, or use Force Reload on the laptop.`);
                    } else {
                        let detail = '';
                        try { detail = await res.text(); } catch (_) {}
                        alert(`âŒ Push failed (${res.status}).\n${detail || 'Check your connection and try again.'}`);
                    }
                } catch (err) {
                    alert('âŒ Push failed: ' + err.message);
                }
            };

            // Retry-aware MongoDB POST â€” handles Render.com cold starts (up to 3 attempts).
            const saveToMongoDB = (mongoData) => {
                const id = 'cincymed-f1-collection';
                const url = `https://f1-card-tracker-backend-1.onrender.com/api/collection/${id}`;
                const attempt = async (triesLeft, delay) => {
                    try {
                        const res = await fetch(url, {
                            method: 'POST',
                            headers: getAuthHeaders(),
                            body: JSON.stringify({ cards: mongoData })
                        });
                        if (res.ok) {
                            console.log('âœ… Collection synced to MongoDB');
                        } else {
                            throw new Error(`HTTP ${res.status}`);
                        }
                    } catch (err) {
                        console.error(`MongoDB save failed (${triesLeft} retries left):`, err.message);
                        if (triesLeft > 0) {
                            setTimeout(() => attempt(triesLeft - 1, delay * 2), delay);
                        } else {
                            // All retries exhausted â€” notify the user
                            const is429 = err.message.includes('429');
                            showToast(
                                is429
                                    ? 'â˜ï¸ Cloud sync delayed â€” server is busy. Your card is saved locally and will sync on next attempt, or use Push to Cloud from the menu.'
                                    : 'â˜ï¸ Cloud sync failed â€” your card is saved locally. Use Push to Cloud from the menu to retry.',
                                7000
                            );
                        }
                    }
                };
                attempt(2, 3000); // first retry after 3s, second after 6s
            };

            // Silent background sync from MongoDB â€” used for cross-device sync.
            // Uses mergeMongoWithLocal so local analyses/grades aren't overwritten.
            // Uses a ref so visibilitychange/polling always call the latest version.
            const silentSyncRef = useRef(null);
            const lastSyncAttemptRef = useRef(0); // throttle: don't sync more than once per 45s

            const silentSyncFromMongo = async () => {
                const now = Date.now();
                if (now - lastSyncAttemptRef.current < 45000) return; // throttle
                lastSyncAttemptRef.current = now;

                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 8000);
                    const response = await fetch(
                        `https://f1-card-tracker-backend-1.onrender.com/api/collection/cincymed-f1-collection`,
                        { method: 'GET', headers: getAuthHeaders(), signal: controller.signal }
                    );
                    clearTimeout(timeoutId);
                    if (response.status === 429) {
                        console.log('Silent sync: rate limited, skipping');
                        return;
                    }
                    if (!response.ok) return;
                    const data = await response.json();
                    if (!data.cards || Object.keys(data.cards).length === 0) return;

                    // Merge MongoDB counts with whatever's in localStorage right now
                    const localRaw = localStorage.getItem('f1-collection-pro-v2');
                    const localColl = localRaw ? JSON.parse(localRaw) : {};
                    const merged = mergeMongoWithLocal(data.cards, localColl);

                    // Only update state+storage if something actually changed
                    if (JSON.stringify(merged) !== localRaw) {
                        setCollection(merged);
                        localStorage.setItem('f1-collection-pro-v2', JSON.stringify(merged));
                        console.log('ðŸ”„ Silent sync: collection updated from MongoDB');
                    }
                } catch (err) {
                    console.log('Silent sync skipped:', err.message);
                }
            };
            silentSyncRef.current = silentSyncFromMongo;

            // Sync when tab becomes visible or window is focused (covers switching back from mobile).
            // The 45s throttle inside silentSyncFromMongo prevents these from causing excess requests.
            useEffect(() => {
                const run = () => silentSyncRef.current?.();
                const onVisibility = () => { if (document.visibilityState === 'visible') run(); };
                document.addEventListener('visibilitychange', onVisibility);
                window.addEventListener('focus', run);
                return () => {
                    document.removeEventListener('visibilitychange', onVisibility);
                    window.removeEventListener('focus', run);
                };
            }, []);

            // Poll MongoDB every 60 seconds to pick up changes from other devices
            useEffect(() => {
                const interval = setInterval(() => silentSyncRef.current?.(), 60000);
                return () => clearInterval(interval);
            }, []);

            const needsVerification = (confidence) => {
                return confidence === 'medium' || confidence === 'low';
            };

            const extractValueEstimates = (analysisText) => {
                if (!analysisText) return null;

                // Strip markdown formatting, normalize dashes, before regex matching
                const cleanText = analysisText
                    .replace(/\*\*/g, '').replace(/\*/g, '')
                    .replace(/^#+\s*/gm, '')
                    .replace(/[â€“â€”]/g, '-');  // normalize en-dash/em-dash to hyphen

                // Robust patterns: handle "Raw: $5-$10", "Raw: 5-10", "Raw (ungraded): ~$5 - $10", etc.
                const rawMatch = cleanText.match(/\bRaw\b[^:\n]{0,25}:\s*~?(?:approximately\s+)?\$?([\d,]+)\s*-\s*~?\$?([\d,]+)/i);
                const psa9Match = cleanText.match(/\bPSA\s*9\b[^:\n]{0,25}:\s*~?(?:approximately\s+)?\$?([\d,]+)\s*-\s*~?\$?([\d,]+)/i);
                const psa10Match = cleanText.match(/\bPSA\s*10\b[^:\n]{0,25}:\s*~?(?:approximately\s+)?\$?([\d,]+)\s*-\s*~?\$?([\d,]+)/i);

                if (!rawMatch && !psa9Match && !psa10Match) return null;

                return {
                    raw: rawMatch ? `$${rawMatch[1]}-$${rawMatch[2]}` : 'N/A',
                    psa9: psa9Match ? `$${psa9Match[1]}-$${psa9Match[2]}` : 'N/A',
                    psa10: psa10Match ? `$${psa10Match[1]}-$${psa10Match[2]}` : 'N/A'
                };
            };

            const calculateCardValue = (cardNum) => {
                const cardKey = getCardKey(cardNum);
                const cardInventory = collection[cardKey] || {};
                const analyses = cardInventory._analyses || {};
                
                let totalMaxValue = 0;
                
                // Get all variants for this card
                Object.keys(cardInventory).forEach(variant => {
                    if (variant.startsWith('_')) return; // Skip metadata (_analyses, _gradeReports)
                    
                    const count = cardInventory[variant];
                    if (count === 0) return; // Skip if no cards
                    
                    // Get latest analysis for this variant
                    const variantAnalyses = analyses[variant] || [];
                    if (variantAnalyses.length === 0) return; // No analysis available
                    
                    const latestAnalysis = variantAnalyses[variantAnalyses.length - 1];
                    
                    // Parse Raw value (using maximum) - strip markdown before matching
                    const cleanAnalysis = latestAnalysis.analysis.replace(/\*\*/g, '').replace(/\*/g, '');
                    const rawMatch = cleanAnalysis.match(/Raw[:\s]*\$?([\d,]+)\s*-\s*\$?([\d,]+)(?:[,.\s]|$)/i);
                    
                    if (rawMatch) {
                        // Get max raw value and remove commas
                        const maxValue = parseInt(rawMatch[2].replace(/,/g, ''));
                        // Multiply by count and add to total
                        totalMaxValue += maxValue * count;
                    }
                });
                
                // Return emoji based on total value
                if (totalMaxValue === 0) return '';
                if (totalMaxValue < 5) return '$';
                if (totalMaxValue < 15) return '$$';
                if (totalMaxValue < 30) return '$$$';
                if (totalMaxValue <= 150) return '$$$$';
                return '$$$$$';
            };

            const resetCollection = () => {
                if (window.confirm('âš ï¸ Are you absolutely sure?\n\nThis will DELETE your entire collection.\n\nThis action CANNOT be undone!')) {
                    localStorage.removeItem('f1-collection-pro-v2');
                    setCollection({});
                    setShowResetConfirm(false);
                    alert('ðŸ—‘ï¸ Collection has been reset.');
                }
            };

            // Get value tier for a card based on $ indicators
            const getCardValueTier = (cardNum) => {
                const valueStr = calculateCardValue(cardNum);
                if (!valueStr) return null;
                const dollarCount = valueStr.length;
                if (dollarCount === 1) return '$';
                if (dollarCount === 2) return '$$';
                if (dollarCount === 3) return '$$$';
                if (dollarCount === 4) return '$$$$';
                if (dollarCount === 5) return '$$$$$';
                return null;
            };

            // Close card detail and return to source page if applicable
            const closeCardDetail = () => {
                setSelectedCard(null);
                setCardDetailEdit(null);
                setOriginalCardDetail(null);
                if (returnTo === 'dashboard') {
                    setReturnTo(null);
                    window.location.href = 'dashboard.html';
                    return;
                }
                setReturnTo(null);
            };

            // Use predefined variant list for filter dropdown
            const allVariants = OFFICIAL_VARIANTS;

            const filteredCards = cardData.filter(card => {
                const matchesSearch = !searchTerm || 
                    card.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    card.num.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    (card.team && card.team.toLowerCase().includes(searchTerm.toLowerCase()));
                
                const matchesSubset = filterSubset === 'all' || card.subset === filterSubset;
                const matchesRookie = filterRookie === 'all' || 
                    (filterRookie === 'rookie' && card.rookie) ||
                    (filterRookie === 'veteran' && !card.rookie);
                
                // Owned only filter
                const matchesOwned = ownedFilter === 'all' || (ownedFilter === 'owned' && getTotalCount(card.num) > 0) || (ownedFilter === 'not_owned' && getTotalCount(card.num) === 0);
                
                // Variant filtering (multi-select)
                const matchesVariant = filterVariants.length === 0 || (() => {
                    const cardKey = getCardKey(card.num);
                    const cardInventory = collection[cardKey];
                    if (!cardInventory) return false; // Card not in collection
                    
                    // Get all variants for this card
                    const cardVariants = Object.keys(cardInventory)
                        .filter(key => key !== '_analyses')
                        .map(variant => {
                            // Normalize variant names for comparison
                            if (variant.includes('Chrome') && !variant.includes('Refractor')) {
                                return 'Base';
                            }
                            return variant;
                        });
                    
                    // Check if any of the card's variants match the filter
                    return cardVariants.some(variant => filterVariants.includes(variant));
                })();
                
                // Value-based filtering (multi-select)
                const matchesValue = filterValues.length === 0 || (() => {
                    const totalCount = getTotalCount(card.num);
                    if (totalCount === 0) return false; // Don't show cards not in collection when filtering by value
                    const tier = getCardValueTier(card.num);
                    return tier && filterValues.includes(tier);
                })();
                
                return matchesSearch && matchesSubset && matchesRookie && matchesVariant && matchesValue && matchesOwned;
            });

            const stats = {
                totalCards: cardData.length,
                cardsOwned: Object.keys(collection).filter(k => !k.startsWith('_')).length,
                totalCopies: getTotalCollectionCount()
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 text-white">
                    {/* Anchored Header - Fixed at Top on Desktop */}
                    <div className={`${isMobile ? 'sticky' : 'fixed'} top-0 left-0 right-0 z-40 bg-slate-900/95 backdrop-blur-sm shadow-xl`}>
                        <div className={`${isMobile ? 'p-2' : 'max-w-7xl mx-auto p-3'}`}>
                            {!serverOnline && (
                                <div className="bg-red-900/20 border border-red-500/30 rounded-lg p-2 mb-2">
                                    <p className={`font-semibold ${isMobile ? 'text-xs' : 'text-sm'} mb-1`}>âš ï¸ Server Offline - AI Scanner Disabled</p>
                                    <p className="text-xs text-red-200 mb-1">
                                        {isMobile ? 'Scanner disabled' : 'The AI card scanner requires a local server'}
                                    </p>
                                    <button onClick={checkServer} className="bg-red-600 hover:bg-red-700 px-3 py-1 rounded text-xs">
                                        Check Again
                                    </button>
                                </div>
                            )}

                            <div className="mb-2">
                                <div className={`flex ${isMobile ? 'flex-col gap-2' : 'justify-between items-start'} mb-1 relative`}>
                                    {/* Hamburger Menu + Title */}
                                    <div className="flex items-center gap-2 md:gap-3 w-full">
                                        {/* Hamburger Menu */}
                                        <div ref={menuRef} className="relative flex-shrink-0">
                                            <button
                                                onClick={() => setShowMenuDropdown(!showMenuDropdown)}
                                                className={`hamburger text-white hover:text-blue-400 transition leading-none ${isMobile ? 'text-lg' : 'text-5xl'}`}
                                                title="Open menu"
                                            >
                                                â˜°
                                            </button>
                                            {showMenuDropdown && (
                                                <div className="dropdown-menu">
                                                    <div className="dropdown-item" onClick={() => { importInputRef.current?.click(); setShowMenuDropdown(false); }}>
                                                        ðŸ“¥ Import
                                                    </div>
                                                    <div className="dropdown-item" onClick={() => { exportCollection(); setShowMenuDropdown(false); }}>
                                                        ðŸ“¤ Export
                                                    </div>
                                                    <div className="dropdown-spacer"></div>
                                                    <div className="dropdown-item" onClick={forcePushToCloud}>
                                                        â˜ï¸ Push to Cloud
                                                    </div>
                                                    <div className="dropdown-item" onClick={forceReloadCollection}>
                                                        ðŸ”„ Force Reload
                                                    </div>
                                                    <div className="dropdown-item" onClick={() => { window.location.reload(); }}>
                                                        ðŸ”ƒ Refresh Page
                                                    </div>
                                                    <div className="dropdown-spacer"></div>
                                                    <div className="dropdown-item" onClick={handleLogout}>
                                                        ðŸšª Logout
                                                    </div>
                                                    {/* Spacer between Logout and Delete */}
                                                    <div className="dropdown-spacer"></div>
                                                    <button
                                                        onClick={() => { setShowExportBeforeDelete(true); setShowMenuDropdown(false); }}
                                                        className="dropdown-item-delete"
                                                    >
                                                        ðŸ—‘ï¸ Delete
                                                    </button>
                                                </div>
                                            )}
                                        </div>
                                        <h1 className={`font-bold bg-gradient-to-r from-blue-400 via-red-500 to-yellow-400 bg-clip-text text-transparent leading-tight ${isMobile ? 'text-lg' : 'text-5xl'}`}>
                                            {isMobile ? '2025 Topps Chrome F1 Cards' : '2025 Topps Chrome F1 Collection'}
                                        </h1>
                                    </div>

                                    <div className={`${isMobile ? 'flex gap-4 w-full' : 'flex gap-8 ml-auto justify-end'}`}>
                                        <div className="flex flex-col items-center gap-1" title="Total number of cards in your collection (including duplicates)">
                                            <span className={`font-bold text-green-400 ${isMobile ? 'text-lg' : 'text-xl'}`}>{stats.totalCopies}</span>
                                            <span className="text-xs text-slate-400">Total Cards</span>
                                        </div>
                                        <div className="flex flex-col items-center gap-1" title="Number of different cards you own out of total cards in set">
                                            <span className={`font-bold text-blue-400 ${isMobile ? 'text-lg' : 'text-xl'}`}>{stats.cardsOwned}/{stats.totalCards}</span>
                                            <span className="text-xs text-slate-400">Unique Cards</span>
                                        </div>
                                        <div className="flex flex-col items-center gap-1" title="Percentage of the complete set you own">
                                            <span className={`font-bold text-purple-400 ${isMobile ? 'text-lg' : 'text-xl'}`}>{((stats.cardsOwned/stats.totalCards)*100).toFixed(1)}%</span>
                                            <span className="text-xs text-slate-400">Complete Set</span>
                                        </div>
                                    </div>
                                </div>
                                <p className="text-slate-400 text-sm">
                                    Pro Tracker {serverOnline && <span className="text-green-400">âœ“ Online</span>}
                                </p>
                            </div>

                            {isMobile ? (
                                // MOBILE: Search + Filters button
                                <div className="space-y-2">
                                    <div className="flex gap-2">
                                        <div className="relative flex-1">
                                            <input
                                                type="text"
                                                placeholder="Search..."
                                                title="Search by driver name or card number"
                                                className="px-3 py-2 pr-10 bg-slate-800 border border-slate-700 rounded-lg focus:border-blue-500 focus:outline-none text-sm w-full"
                                                value={searchTerm}
                                                onChange={(e) => setSearchTerm(e.target.value)}
                                            />
                                            {searchTerm && (
                                                <button
                                                    onClick={() => setSearchTerm('')}
                                                    className="absolute right-2 top-1/2 -translate-y-1/2 text-slate-400 hover:text-white transition-colors"
                                                    title="Clear search"
                                                >
                                                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                                    </svg>
                                                </button>
                                            )}
                                        </div>
                                        <button
                                            onClick={() => setShowFiltersDropdown(!showFiltersDropdown)}
                                            className="px-3 py-2 bg-slate-800 border border-slate-700 rounded-lg text-sm font-semibold hover:bg-slate-700 transition-colors flex items-center gap-2 whitespace-nowrap"
                                            title="Open filters menu"
                                        >
                                            ðŸ”½ Filters
                                        </button>
                                    </div>
                                    {showFiltersDropdown && (
                                        <div className="bg-slate-800 border border-slate-700 rounded-lg p-3 space-y-3">
                                            {/* Subset Filter - Now First */}
                                            {/* Variant Filter - Now First */}
                                            <div>
                                                <label className="text-xs font-semibold text-slate-400 block mb-2">Variant Type</label>
                                                <select
                                                    className="w-full px-2 py-2 bg-slate-700 border border-slate-600 rounded text-sm"
                                                    title="Filter by variant type"
                                                    value={filterVariants.length > 0 ? filterVariants[0] : ''}
                                                    onChange={(e) => {
                                                        setFilterVariants(e.target.value ? [e.target.value] : []);
                                                    }}
                                                >
                                                    <option value="">All Variants</option>
                                                    {VARIANT_GROUPS.map(group => (
                                                        <optgroup key={group.label} label={group.label}>
                                                            {group.variants.map(v => {
                                                                const count = getVariantTotalCount(v);
                                                                const prefix = count > 0 ? `(${count})` : '';
                                                                const pad = '\u00A0'.repeat(Math.max(0, 6 - prefix.length));
                                                                return <option key={v} value={v}>{prefix}{pad}{v}</option>;
                                                            })}
                                                        </optgroup>
                                                    ))}
                                                </select>
                                            </div>
                                            {/* Subset Filter - Now Second */}
                                            <div>
                                                <label className="text-xs font-semibold text-slate-400 block mb-2">Subset</label>
                                                <select
                                                    className="w-full px-2 py-2 bg-slate-700 border border-slate-600 rounded text-sm"
                                                    title="Filter cards by subset (F1Â® Drivers, Inserts, etc.)"
                                                    value={filterSubset}
                                                    onChange={(e) => setFilterSubset(e.target.value)}
                                                >
                                                    <option value="all">All Subsets</option>
                                                    {allSubsets.map(s => <option key={s} value={s}>{s}</option>)}
                                                </select>
                                            </div>
                                            {/* Rookies Filter */}
                                            <div>
                                                <label className="text-xs font-semibold text-slate-400 block mb-2">Card Type</label>
                                                <select
                                                    className="w-full px-2 py-2 bg-slate-700 border border-slate-600 rounded text-sm"
                                                    title="Show all cards or only rookies/veterans"
                                                    value={filterRookie}
                                                    onChange={(e) => setFilterRookie(e.target.value)}
                                                >
                                                    <option value="all">Rookies and Veterans</option>
                                                    <option value="rookie">Rookies</option>
                                                    <option value="veteran">Veterans</option>
                                                </select>
                                            </div>
                                            {/* Value Filter */}
                                            <div>
                                                <label className="text-xs font-semibold text-slate-400 block mb-2">Value Estimate</label>
                                                <select
                                                    className="w-full px-2 py-2 bg-slate-700 border border-slate-600 rounded text-sm"
                                                    title="Value Estimate ($)"
                                                    value={filterValues.length > 0 ? filterValues[0] : ''}
                                                    onChange={(e) => {
                                                        setFilterValues(e.target.value ? [e.target.value] : []);
                                                    }}
                                                >
                                                    <option value="">All Values</option>
                                                    <option value="$$$$$">$$$$$ (&gt;$150)</option>
                                                    <option value="$$$$">$$$$ ($30-$150)</option>
                                                    <option value="$$$">$$$ ($15-$30)</option>
                                                    <option value="$$">$$ ($5-$15)</option>
                                                    <option value="$">$ (&lt;$5)</option>
                                                </select>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            ) : (
                                // DESKTOP: All filters in grid
                                <div className="grid grid-cols-1 md:grid-cols-5 gap-2">
                                    <select
                                        className="px-3 py-2 bg-slate-800 border border-slate-700 rounded-lg text-sm"
                                        title="Filter cards by subset (F1Â® Drivers, Inserts, etc.)"
                                        value={filterSubset}
                                        onChange={(e) => setFilterSubset(e.target.value)}
                                    >
                                        <option value="all">All Subsets</option>
                                        {allSubsets.map(s => <option key={s} value={s}>{s}</option>)}
                                    </select>
                                    <select
                                        className="px-3 py-2 bg-slate-800 border border-slate-700 rounded-lg text-sm"
                                        title="Filter by variant type"
                                        value={filterVariants.length > 0 ? filterVariants[0] : ''}
                                        onChange={(e) => {
                                            setFilterVariants(e.target.value ? [e.target.value] : []);
                                        }}
                                    >
                                        <option value="">All Variants</option>
                                        {VARIANT_GROUPS.map(group => (
                                            <optgroup key={group.label} label={group.label}>
                                                {group.variants.map(v => {
                                                    const count = getVariantTotalCount(v);
                                                    const prefix = count > 0 ? `(${count})` : '';
                                                    const pad = '\u00A0'.repeat(Math.max(0, 6 - prefix.length));
                                                    return <option key={v} value={v}>{prefix}{pad}{v}</option>;
                                                })}
                                            </optgroup>
                                        ))}
                                    </select>
                                    <select
                                        className="px-3 py-2 bg-slate-800 border border-slate-700 rounded-lg text-sm"
                                        title="Show all cards or only rookies/veterans"
                                        value={filterRookie}
                                        onChange={(e) => setFilterRookie(e.target.value)}
                                    >
                                        <option value="all">Rookies and Veterans</option>
                                        <option value="rookie">Rookies</option>
                                        <option value="veteran">Veterans</option>
                                    </select>
                                    <select
                                        className="px-3 py-2 bg-slate-800 border border-slate-700 rounded-lg text-sm"
                                        title="Value Estimate ($)"
                                        value={filterValues.length > 0 ? filterValues[0] : ''}
                                        onChange={(e) => {
                                            setFilterValues(e.target.value ? [e.target.value] : []);
                                        }}
                                    >
                                        <option value="">Value Estimate ($)</option>
                                        <option value="$$$$$">$$$$$ (&gt;$150)</option>
                                        <option value="$$$$">$$$$ ($30-$150)</option>
                                        <option value="$$$">$$$ ($15-$30)</option>
                                        <option value="$$">$$ ($5-$15)</option>
                                        <option value="$">$ (&lt;$5)</option>
                                    </select>
                                    <div className="relative">
                                        <input
                                            type="text"
                                            placeholder="Search..."
                                            title="Search by driver name or card number"
                                            className="px-3 py-2 pr-10 bg-slate-800 border border-slate-700 rounded-lg focus:border-blue-500 focus:outline-none text-sm w-full"
                                            value={searchTerm}
                                            onChange={(e) => setSearchTerm(e.target.value)}
                                        />
                                        {searchTerm && (
                                            <button
                                                onClick={() => setSearchTerm('')}
                                                className="absolute right-2 top-1/2 -translate-y-1/2 text-slate-400 hover:text-white transition-colors"
                                                title="Clear search"
                                            >
                                                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                                </svg>
                                            </button>
                                        )}
                                    </div>
                                </div>
                            )}
                            
                            {/* All/Owned Toggle + Card Count - Always Visible at Bottom of Header */}
                            <div className={`flex items-center gap-3 ${isMobile ? 'mt-3 pt-2 border-t border-slate-700' : 'mt-4 pt-3 border-t border-slate-700'}`}>
                                <div className="flex items-center bg-slate-800 rounded-full p-0.5 border border-slate-600">
                                    <button
                                        onClick={() => setOwnedFilter('all')}
                                        className={`px-4 py-1.5 rounded-full text-xs font-semibold transition-all ${
                                            ownedFilter === 'all'
                                                ? 'bg-blue-600 text-white shadow-md'
                                                : 'text-slate-400 hover:text-slate-200'
                                        }`}
                                    >
                                        All
                                    </button>
                                    <button
                                        onClick={() => setOwnedFilter('owned')}
                                        className={`px-4 py-1.5 rounded-full text-xs font-semibold transition-all ${
                                            ownedFilter === 'owned'
                                                ? 'bg-green-600 text-white shadow-md'
                                                : 'text-slate-400 hover:text-slate-200'
                                        }`}
                                    >
                                        Owned
                                    </button>
                                    <button
                                        onClick={() => setOwnedFilter('not_owned')}
                                        className={`px-4 py-1.5 rounded-full text-xs font-semibold transition-all ${
                                            ownedFilter === 'not_owned'
                                                ? 'bg-red-600 text-white shadow-md'
                                                : 'text-slate-400 hover:text-slate-200'
                                        }`}
                                    >
                                        Not Owned
                                    </button>
                                </div>
                                <span className="text-slate-400 text-sm">
                                    {(() => {
                                        // Count cards matching all filters EXCEPT the owned-only filter
                                        const totalMatchingFilters = cardData.filter(card => {
                                            const matchesSearch = !searchTerm ||
                                                card.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                                card.num.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                                (card.team && card.team.toLowerCase().includes(searchTerm.toLowerCase()));
                                            const matchesSubset = filterSubset === 'all' || card.subset === filterSubset;
                                            const matchesRookie = filterRookie === 'all' ||
                                                (filterRookie === 'rookie' && card.rookie) ||
                                                (filterRookie === 'veteran' && !card.rookie);
                                            return matchesSearch && matchesSubset && matchesRookie;
                                        }).length;

                                        if (filteredCards.length === totalMatchingFilters) {
                                            return `Showing ${filteredCards.length} cards`;
                                        }
                                        return `Showing ${filteredCards.length} of ${totalMatchingFilters} cards`;
                                    })()}
                                </span>
                            </div>
                        </div>
                    </div>

                    {/* Bulk Select Mode Banner */}
                    {bulkSelectMode && (
                        <div className="fixed top-0 left-0 right-0 z-50 bg-gradient-to-r from-purple-700 to-purple-900 border-b-2 border-purple-400 shadow-lg shadow-purple-500/20 px-4 py-3">
                            <div className="max-w-7xl mx-auto flex items-center justify-between">
                                <div className="flex items-center gap-3">
                                    <span className="text-2xl">ðŸ”¬</span>
                                    <div>
                                        <div className="text-white font-bold text-sm">Bulk Analyze â€” Select Cards</div>
                                        <div className="text-purple-200 text-xs">Tap owned cards to select them for analysis. {bulkSelectedCards.size > 0 ? `${bulkSelectedCards.size} card${bulkSelectedCards.size !== 1 ? 's' : ''} selected.` : 'No cards selected yet.'}</div>
                                    </div>
                                </div>
                                <div className="flex gap-2">
                                    <button onClick={cancelBulkSelect} className="bg-slate-600 hover:bg-slate-500 text-white text-xs px-3 py-1.5 rounded-lg font-semibold transition-colors">
                                        Cancel
                                    </button>
                                    <button
                                        onClick={handleBulkAnalyzeClick}
                                        disabled={bulkSelectedCards.size === 0}
                                        className="bg-purple-500 hover:bg-purple-400 disabled:opacity-40 disabled:cursor-not-allowed text-white text-xs px-3 py-1.5 rounded-lg font-semibold transition-colors"
                                    >
                                        Analyze {bulkSelectedCards.size > 0 ? `(${bulkSelectedCards.size})` : ''}
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Bulk Analyzing Progress Banner */}
                    {bulkAnalyzing && (
                        <div className="fixed top-0 left-0 right-0 z-50 bg-gradient-to-r from-blue-700 to-blue-900 border-b-2 border-blue-400 shadow-lg px-4 py-3">
                            <div className="max-w-7xl mx-auto flex items-center gap-3">
                                <span className="text-2xl animate-spin">â³</span>
                                <div className="flex-1">
                                    <div className="text-white font-bold text-sm">Analyzing card {bulkAnalyzeProgress.current} of {bulkAnalyzeProgress.total}...</div>
                                    <div className="w-full bg-blue-950 rounded-full h-2 mt-1">
                                        <div className="bg-blue-400 h-2 rounded-full transition-all duration-500" style={{width: `${(bulkAnalyzeProgress.current / bulkAnalyzeProgress.total) * 100}%`}}></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Main Content */}
                    <div className={`${isMobile ? 'p-3 pb-24 pt-4' : 'max-w-7xl mx-auto p-4 pt-64'}`}>
                        {/* Card Grid with page numbers and separators every 12 cards */}
                        <div className="space-y-6">
                            {Array.from({ length: Math.ceil(filteredCards.length / 12) }).map((_, groupIndex) => {
                                const startIdx = groupIndex * 12;
                                const groupCards = filteredCards.slice(startIdx, startIdx + 12);
                                const startCardNum = startIdx + 1;
                                const endCardNum = Math.min(startIdx + 12, filteredCards.length);
                                
                                return (
                                    <div key={groupIndex}>
                                        <div className="page-container flex items-start">
                                            {/* Large page number in left margin with long-press menu */}
                                            <div 
                                                className="page-number flex-shrink-0 relative"
                                                title="Long-press to jump to any page"
                                                onMouseDown={() => {
                                                    const pressTimer = setTimeout(() => {
                                                        // Show page selection menu
                                                        const pageCount = Math.ceil(filteredCards.length / 12);
                                                        const pageMenuItems = Array.from({length: pageCount}).map((_, i) => `
                                                            <div class="page-menu-item ${i === groupIndex ? 'active' : ''}" data-page="${i}">
                                                                <span style="display: flex; align-items: center; gap: 8px;">
                                                                    ${i === groupIndex ? '<span style="font-size: 10px;">â–¸</span>' : '<span style="font-size: 10px; opacity: 0.3;">Â·</span>'}
                                                                    Page ${i + 1}
                                                                </span>
                                                            </div>
                                                        `).join('');

                                                        const menuHtml = `
                                                            <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 9999; backdrop-filter: blur(2px); background: rgba(0,0,0,0.3);" id="pageMenuOverlay">
                                                                <div style="position: fixed; left: 80px; top: 240px; background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 12px; box-shadow: 0 20px 60px rgba(0,0,0,0.6), 0 0 20px rgba(59, 130, 246, 0.1); z-index: 10000; max-height: 420px; overflow-y: auto; min-width: 150px; scrollbar-width: thin; scrollbar-color: #334155 transparent;" id="pageMenu">
                                                                    <div style="padding: 10px 18px 8px; font-size: 11px; font-weight: 700; color: #64748b; text-transform: uppercase; letter-spacing: 0.08em; border-bottom: 1px solid rgba(51, 65, 85, 0.5);">Jump to Page</div>
                                                                    ${pageMenuItems}
                                                                </div>
                                                            </div>
                                                        `;
                                                        document.body.insertAdjacentHTML('beforeend', menuHtml);

                                                        // Scroll the menu to show current page centered
                                                        const menuEl = document.getElementById('pageMenu');
                                                        const activeItem = menuEl?.querySelector('.page-menu-item.active');
                                                        if (activeItem && menuEl) {
                                                            activeItem.scrollIntoView({ block: 'center', behavior: 'instant' });
                                                        }
                                                        
                                                        // Add event listeners to menu items
                                                        document.querySelectorAll('.page-menu-item').forEach(item => {
                                                            item.addEventListener('click', function(e) {
                                                                e.stopPropagation();
                                                                const pageNum = parseInt(this.dataset.page);
                                                                const pageElements = document.querySelectorAll('.page-container');
                                                                if (pageElements[pageNum]) {
                                                                    pageElements[pageNum].scrollIntoView({behavior: 'smooth', block: 'start'});
                                                                }
                                                                document.getElementById('pageMenuOverlay')?.remove();
                                                            });
                                                        });
                                                        
                                                        // Close menu on overlay click
                                                        document.getElementById('pageMenuOverlay')?.addEventListener('click', (e) => {
                                                            if (e.target.id === 'pageMenuOverlay') document.getElementById('pageMenuOverlay')?.remove();
                                                        });
                                                    }, 500);
                                                    
                                                    const cleanup = () => clearTimeout(pressTimer);
                                                    document.addEventListener('mouseup', cleanup, {once: true});
                                                }}
                                            >
                                                Page {groupIndex + 1}
                                            </div>
                                            
                                            <div className="flex-1">
                                            <div className="card-grid mb-4">
                                                {groupCards.map(card => {
                                                    const totalCount = getTotalCount(card.num);
                                                    const hasCard = totalCount > 0;
                                                    const variantBreakdown = getVariantBreakdown(card.num);
                                                    const cardKey = getCardKey(card.num);
                                                    const cardInventory = collection[cardKey] || {};
                                                    const analyses = cardInventory._analyses || {};

                                                    const isBulkSelected = bulkSelectMode && bulkSelectedCards.has(card.num);

                                                    return (
                                                        <div
                                                            key={card.num}
                                                            className={`rounded-xl p-4 border-2 cursor-pointer hover:scale-105 transition-all relative ${
                                                                isBulkSelected
                                                                    ? 'border-purple-400 bg-purple-900/40 shadow-lg shadow-purple-500/30 ring-2 ring-purple-400/50'
                                                                    : hasCard
                                                                    ? 'border-green-500 shadow-lg shadow-green-500/20 bg-slate-800/50'
                                                                    : 'border-slate-700 bg-slate-800/50'
                                                            }`}
                                                            onClick={() => {
                                                                if (bulkSelectMode) {
                                                                    if (hasCard) toggleBulkSelect(card.num);
                                                                } else {
                                                                    setSelectedCard(card);
                                                                }
                                                            }}
                                                        >
                                                            {/* Bulk select checkmark overlay */}
                                                            {bulkSelectMode && hasCard && (
                                                                <div className={`absolute top-2 right-2 w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold z-10 ${
                                                                    isBulkSelected ? 'bg-purple-500 text-white' : 'bg-slate-600 text-slate-400 border border-slate-500'
                                                                }`}>
                                                                    {isBulkSelected ? 'âœ“' : ''}
                                                                </div>
                                                            )}
                                                            <div className="mb-2">
                                                                <div className="flex items-center gap-2 mb-1">
                                                                    <span className="text-lg font-bold text-blue-400">#{card.num}</span>
                                                                    <span className="text-lg font-semibold text-white line-clamp-1 flex-1">{card.name}</span>
                                                                    {card.rookie && (
                                                                        <span className="bg-yellow-500 text-black text-xs px-2 py-0.5 rounded-full font-bold" title="Rookie Card - Driver's first official trading card">RC</span>
                                                                    )}
                                                                </div>
                                                            </div>
                                                            {card.team && <p className="text-xs text-slate-400 mb-2 line-clamp-1">{card.team}</p>}
                                                            <p className="text-xs text-slate-500 bg-slate-900/50 px-2 py-1 rounded mb-3">{card.subset}</p>
                                                            
                                                            {/* Variant breakdown without analysis on main page */}
                                                            {hasCard && (
                                                                <div className="mb-2">
                                                                    {(() => {
                                                                        // Sort variants by PSA 10 max value in ascending order (highest value first)
                                                                        const sortedVariants = [...variantBreakdown].sort((a, b) => {
                                                                            const aAnalyses = analyses[a.variant] || [];
                                                                            const bAnalyses = analyses[b.variant] || [];
                                                                            
                                                                            let aValue = 0;
                                                                            let bValue = 0;
                                                                            
                                                                            if (aAnalyses.length > 0) {
                                                                                const aValues = extractValueEstimates(aAnalyses[aAnalyses.length - 1].analysis);
                                                                                if (aValues && aValues.psa10 !== 'N/A') {
                                                                                    const aMatch = aValues.psa10.match(/\$?([\d,]+)-\$?([\d,]+)/);
                                                                                    if (aMatch) {
                                                                                        aValue = parseInt(aMatch[2].replace(/,/g, ''));
                                                                                    }
                                                                                }
                                                                            }
                                                                            
                                                                            if (bAnalyses.length > 0) {
                                                                                const bValues = extractValueEstimates(bAnalyses[bAnalyses.length - 1].analysis);
                                                                                if (bValues && bValues.psa10 !== 'N/A') {
                                                                                    const bMatch = bValues.psa10.match(/\$?([\d,]+)-\$?([\d,]+)/);
                                                                                    if (bMatch) {
                                                                                        bValue = parseInt(bMatch[2].replace(/,/g, ''));
                                                                                    }
                                                                                }
                                                                            }
                                                                            
                                                                            return bValue - aValue; // Descending (highest value first)
                                                                        });
                                                                        
                                                                        // Find the most expensive variant by Raw max value
                                                                        let mostExpensiveVariant = null;
                                                                        let maxRawValue = 0;
                                                                        
                                                                        variantBreakdown.forEach(v => {
                                                                            const variantAnalyses = analyses[v.variant] || [];
                                                                            if (variantAnalyses.length > 0) {
                                                                                const latestAnalysis = variantAnalyses[variantAnalyses.length - 1];
                                                                                const values = extractValueEstimates(latestAnalysis.analysis);
                                                                                if (values && values.raw !== 'N/A') {
                                                                                    const rawMatch = values.raw.match(/\$?([\d,]+)-\$?([\d,]+)/);
                                                                                    if (rawMatch) {
                                                                                        const rawMax = parseInt(rawMatch[2].replace(/,/g, ''));
                                                                                        if (rawMax > maxRawValue) {
                                                                                            maxRawValue = rawMax;
                                                                                            mostExpensiveVariant = v.variant;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        });
                                                                        
                                                                        return sortedVariants.map((v, idx) => {
                                                                            const isExpensive = v.variant === mostExpensiveVariant;
                                                                            
                                                                            return (
                                                                                <div key={idx} className="mb-2">
                                                                                    <div className={`flex items-center justify-between bg-slate-900/30 rounded px-2 py-1 ${isExpensive ? 'ring-2 ring-green-700' : ''}`}>
                                                                                        <div className="flex items-center gap-2">
                                                                                            <div
                                                                                                className={`relative w-7 h-7 rounded-full shadow-sm overflow-hidden ${!v.style.svg ? v.style.bg : ''}`}
                                                                                                title={v.variant}
                                                                                            >
                                                                                                {v.style.svg ? (
                                                                                                    renderCheckerBadge(v.style, v.style.text)
                                                                                                ) : (
                                                                                                    <div className="flex items-center justify-center w-full h-full text-white text-xs font-bold">
                                                                                                        {v.style.text}
                                                                                                    </div>
                                                                                                )}
                                                                                            </div>
                                                                                            <span className="text-xs text-slate-300">{v.variant}</span>
                                                                                        </div>
                                                                                        <span className="text-xs font-bold text-green-400" title="Number of this variant in your collection">Ã—{v.count}</span>
                                                                                    </div>
                                                                                </div>
                                                                            );
                                                                        });
                                                                    })()}
                                                                </div>
                                                            )}
                                                            
                                                            {/* Value Estimates Below Variants - Most Expensive Variant */}
                                                            {hasCard && (() => {
                                                                // Find the most expensive variant by Raw max value
                                                                let mostExpensiveVariant = null;
                                                                let maxRawValue = 0;
                                                                let mostExpensiveValues = null;
                                                                
                                                                variantBreakdown.forEach(v => {
                                                                    const variantAnalyses = analyses[v.variant] || [];
                                                                    if (variantAnalyses.length > 0) {
                                                                        const latestAnalysis = variantAnalyses[variantAnalyses.length - 1];
                                                                        const values = extractValueEstimates(latestAnalysis.analysis);
                                                                        if (values && values.raw !== 'N/A') {
                                                                            const rawMatch = values.raw.match(/\$?([\d,]+)-\$?([\d,]+)/);
                                                                            if (rawMatch) {
                                                                                const rawMax = parseInt(rawMatch[2].replace(/,/g, ''));
                                                                                if (rawMax > maxRawValue) {
                                                                                    maxRawValue = rawMax;
                                                                                    mostExpensiveVariant = v.variant;
                                                                                    mostExpensiveValues = values;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                });
                                                                
                                                                if (!mostExpensiveValues) return null;
                                                                
                                                                return (
                                                                    <div className="mt-3 flex flex-col items-center gap-2">
                                                                        <div className="flex items-center gap-3">
                                                                            {/* $ Indicator - Vertically Centered */}
                                                                            <span className="text-lg font-bold text-green-400" style={{textShadow: '0 0 10px rgba(34, 197, 94, 0.5)'}} title="Estimated total collection value (Raw max values): $ = <$5, $$ = $5-40, $$$ = $40-100, $$$$ = $100-500, $$$$$ = >$500">
                                                                                {calculateCardValue(card.num)}
                                                                            </span>

                                                                            {/* Value Box */}
                                                                            <div className="text-xs space-y-0.5 bg-slate-900/80 rounded px-2 py-1 ring-2 ring-green-700 text-center">
                                                                                <div className="text-slate-300" title="Most expensive variant - Raw value range">Raw: {mostExpensiveValues.raw}</div>
                                                                                <div className="text-blue-400" title="Most expensive variant - PSA 9 value range">PSA 9: {mostExpensiveValues.psa9}</div>
                                                                                <div className="text-yellow-400" title="Most expensive variant - PSA 10 value range">PSA 10: {mostExpensiveValues.psa10}</div>
                                                                            </div>

                                                                            {/* Count Badge */}
                                                                            <span className="bg-green-500 text-white text-sm px-3 py-1.5 rounded-full font-bold shadow-lg" title="Total number of this card in your collection">
                                                                                {totalCount}
                                                                            </span>
                                                                        </div>
                                                                    </div>
                                                                );
                                                            })()}
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                        
                                        {/* Horizontal separator between pages */}
                                        {groupIndex < Math.ceil(filteredCards.length / 12) - 1 && (
                                            <div className="my-6">
                                                <div className="w-full border-t-2 border-slate-700/50"></div>
                                            </div>
                                        )}
                                    </div>
                                    </div>
                                );
                            })}
                        </div>

                        {/* Hidden import input - referenced by hamburger menu */}
                        <input
                            ref={importInputRef}
                            type="file"
                            accept=".json"
                            onChange={importCollection}
                            className="hidden"
                        />

                        {/* Right Sidebar - Fixed buttons at bottom */}
                        {/* AI Scanner, Dashboard & Bulk Analyze - Bottom Right */}
                        <div className={`fixed ${isMobile ? 'bottom-4 left-4 right-4' : 'bottom-6 right-6'} z-40 ${isMobile ? 'flex gap-2' : 'flex flex-col gap-3'}`}>
                            <button
                                onClick={() => {
                                    // Clear any leftover state from previous scan
                                    setUploadedImages([]);
                                    setPendingImages([]);
                                    setScannerCapturedImages([]);
                                    setRecognizedCard(null);
                                    setRecognitionError(null);
                                    setEditedCard(null);
                                    setIsEditing(false);
                                    setDeepAnalysis(null);
                                    setSelectedAnalysisSource('opus');
                                    setShowImageUpload(true);
                                }}
                                disabled={!serverOnline}
                                title={serverOnline ? "Open AI Scanner to analyze card images (upload front and back)" : "Server offline - start server to enable AI scanning"}
                                className={`bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 text-white rounded-lg font-semibold shadow-lg disabled:opacity-50 flex flex-col items-center justify-center gap-2 transition-all ${isMobile ? 'flex-1 py-3' : 'px-4 py-3 w-28'}`}
                                style={isMobile ? {height: '60px'} : {height: '120px'}}
                            >
                                <span className={isMobile ? 'text-3xl' : 'text-4xl'}>ðŸ“·</span>
                                <span className={isMobile ? 'text-xs' : 'text-sm'}>Scanner</span>
                                {!serverOnline && <span className="text-xs text-red-300">Offline</span>}
                            </button>

                            {/* Dashboard Button */}
                            <a
                                href="dashboard.html"
                                className={`bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-semibold shadow-lg flex flex-col items-center justify-center gap-2 transition-all ${isMobile ? 'flex-1 py-3' : 'px-4 py-3 w-28'}`}
                                style={isMobile ? {height: '60px'} : {height: '120px'}}
                                title="View your collection dashboard and analytics"
                            >
                                <span className={isMobile ? 'text-2xl' : 'text-4xl'}>ðŸ“Š</span>
                                <span className={isMobile ? 'text-xs' : 'text-sm'}>Dashboard</span>
                            </a>

                            {/* Bulk Analyze Button - Desktop only */}
                            {!isMobile && (
                                <button
                                    onClick={handleBulkAnalyzeClick}
                                    disabled={!serverOnline || bulkAnalyzing}
                                    title={bulkAnalyzing ? `Analyzing ${bulkAnalyzeProgress.current}/${bulkAnalyzeProgress.total}...` : bulkSelectMode ? `Analyze ${bulkSelectedCards.size} selected cards` : "Select cards for bulk analysis (Sonnet)"}
                                    className={`bg-gradient-to-r ${bulkSelectMode ? 'from-purple-500 to-purple-600 ring-2 ring-purple-300' : 'from-purple-600 to-purple-700'} hover:from-purple-700 hover:to-purple-800 text-white rounded-lg font-semibold shadow-lg disabled:opacity-50 flex flex-col items-center justify-center gap-2 transition-all px-4 py-3 w-28`}
                                    style={{height: '120px'}}
                                >
                                    <span className="text-4xl">{bulkAnalyzing ? 'â³' : bulkSelectMode ? 'âœ“' : 'ðŸ”¬'}</span>
                                    <span className="text-sm text-center leading-tight">{bulkAnalyzing ? `${bulkAnalyzeProgress.current}/${bulkAnalyzeProgress.total}` : bulkSelectMode ? (bulkSelectedCards.size > 0 ? `Analyze (${bulkSelectedCards.size})` : 'Select Cards') : 'Bulk Analyze'}</span>
                                </button>
                            )}
                        </div>

                        {selectedCard && (
                            <div className="fixed inset-0 bg-black/80 flex items-center justify-center p-4 z-50" onClick={() => {
                                closeCardDetail();
                            }}>
                                <div className={`bg-slate-800 rounded-2xl p-6 ${isMobile ? 'w-full max-h-[95vh]' : 'max-w-4xl w-full max-h-[90vh]'} overflow-y-auto scrollbar-hide`} onClick={(e) => e.stopPropagation()}>
                                    <div className={`flex ${isMobile ? 'flex-col gap-4' : 'justify-between items-start'} mb-6`}>
                                        <div className="flex-1">
                                            <h2 className={`${isMobile ? 'text-2xl' : 'text-3xl'} font-bold mb-2`}>#{selectedCard.num} {selectedCard.name}</h2>
                                            {selectedCard.team && <p className="text-slate-400 text-sm">{selectedCard.team}</p>}
                                            <p className="text-xs text-slate-500">{selectedCard.subset}</p>
                                        </div>
                                        <div className={`flex ${isMobile ? 'w-full gap-2' : 'gap-2 items-start'}`}>
                                            <button
                                                onClick={() => {
                                                    // Save changes
                                                    if (cardDetailEdit) {
                                                        saveCollection(collection);
                                                    }
                                                    closeCardDetail();
                                                }}
                                                title="Save changes and close"
                                                className={`bg-green-600 hover:bg-green-700 rounded-lg font-semibold ${isMobile ? 'flex-1 py-3 text-base' : 'px-4 py-2 text-sm'}`}
                                            >
                                                âœ“ Done
                                            </button>
                                            <button
                                                onClick={() => {
                                                    // Cancel changes and restore original
                                                    if (originalCardDetail) {
                                                        // Restore original data
                                                        const key = getCardKey(selectedCard.num);
                                                        const newCollection = { ...collection };
                                                        newCollection[key] = originalCardDetail;
                                                        setCollection(newCollection);
                                                        saveCollection(newCollection);
                                                    }
                                                    closeCardDetail();
                                                }}
                                                title="Discard changes and close"
                                                className={`bg-red-600 hover:bg-red-700 rounded-lg font-semibold ${isMobile ? 'flex-1 py-3 text-base' : 'px-4 py-2 text-sm'}`}
                                            >
                                                âœ• Cancel
                                            </button>
                                        </div>
                                    </div>

                                    <div>
                                        <h3 className="text-xl font-semibold mb-4">Inventory</h3>
                                        <div className="space-y-2">
                                            {(() => {
                                                const cardKey = getCardKey(selectedCard.num);
                                                const cardInventory = collection[cardKey] || {};
                                                // Get variants that actually exist in the collection for this card
                                                const existingVariants = Object.keys(cardInventory)
                                                    .filter(key => !key.startsWith('_') && cardInventory[key] > 0)
                                                    .sort((a, b) => OFFICIAL_VARIANTS.indexOf(a) - OFFICIAL_VARIANTS.indexOf(b));
                                                
                                                return existingVariants.map(variant => {
                                                    const count = cardInventory[variant] || 0;
                                                    const analyses = cardInventory._analyses || {};
                                                    const variantAnalyses = analyses[variant] || [];
                                                    const latestAnalysis = variantAnalyses.length > 0 ? variantAnalyses[variantAnalyses.length - 1] : null;
                                                    const isAnalyzing = analyzingCards[`${selectedCard.num}-${variant}`];
                                                    
                                                    return (
                                                        <div key={variant} className="bg-slate-900/50 rounded-lg p-4 border border-slate-700">
                                                            <div className="flex items-center justify-between mb-3">
                                                                <span className="text-sm font-medium">{variant}</span>
                                                            </div>
                                                            {/* Analysis & Grading + Add/Delete Card controls */}
                                                            <div className={`flex ${isMobile ? 'flex-col' : 'flex-row'} items-stretch gap-3 mb-3`}>
                                                                <div className="bg-slate-800/60 rounded-lg p-2.5 border border-slate-600/40 flex-1 flex flex-col">
                                                                    <div className="text-xs font-semibold text-slate-400 mb-1.5 uppercase tracking-wider">Analysis & Grading</div>
                                                                    <div className="flex gap-1.5 flex-wrap items-center flex-1">
                                                                        <button
                                                                            onClick={async (e) => {
                                                                                e.stopPropagation();
                                                                                const analyzeKey = `${selectedCard.num}-${variant}`;
                                                                                const cardKey = getCardKey(selectedCard.num);
                                                                                setAnalyzingCards(prev => ({ ...prev, [analyzeKey]: true }));
                                                                                try {
                                                                                    const newAnalysis = await analyzeCardValue(selectedCard.num, variant);
                                                                                    if (newAnalysis) {
                                                                                        setCollection(prevCollection => {
                                                                                            const updatedCollection = JSON.parse(JSON.stringify(prevCollection));
                                                                                            if (!updatedCollection[cardKey]) updatedCollection[cardKey] = {};
                                                                                            if (!updatedCollection[cardKey]._analyses) updatedCollection[cardKey]._analyses = {};
                                                                                            if (!updatedCollection[cardKey]._analyses[variant]) updatedCollection[cardKey]._analyses[variant] = [];
                                                                                            updatedCollection[cardKey]._analyses[variant].push({
                                                                                                id: Date.now(),
                                                                                                addedDate: new Date().toISOString(),
                                                                                                analysis: newAnalysis,
                                                                                                source: 'sonnet'
                                                                                            });
                                                                                            trimAnalyses(updatedCollection, 3);
                                                                                            localStorage.setItem('f1-collection-pro-v2', JSON.stringify(updatedCollection));
                                                                                            const mongoData = stripMetadataForMongo(updatedCollection);
                                                                                            fetch(`https://f1-card-tracker-backend-1.onrender.com/api/collection/cincymed-f1-collection`, {
                                                                                                method: 'POST',
                                                                                                headers: getAuthHeaders(),
                                                                                                body: JSON.stringify({ cards: mongoData })
                                                                                            }).catch(err => console.error('MongoDB sync error:', err));
                                                                                            return updatedCollection;
                                                                                        });
                                                                                    }
                                                                                } catch (error) {
                                                                                    console.error('Analysis error:', error);
                                                                                } finally {
                                                                                    setAnalyzingCards(prev => {
                                                                                        const updated = { ...prev };
                                                                                        delete updated[analyzeKey];
                                                                                        return updated;
                                                                                    });
                                                                                }
                                                                            }}
                                                                            disabled={isAnalyzing}
                                                                            className={`bg-blue-600 hover:bg-blue-700 text-white rounded font-semibold disabled:opacity-50 ${isMobile ? 'px-3 py-2 text-sm' : 'px-4 py-2 text-sm'}`}
                                                                            title="Analyze value with Sonnet model"
                                                                        >
                                                                            {isAnalyzing ? 'âŸ³' : 'âš¡'} Sonnet
                                                                        </button>
                                                                        <button
                                                                            onClick={async (e) => {
                                                                                e.stopPropagation();
                                                                                const analyzeKey = `${selectedCard.num}-${variant}`;
                                                                                const cardKey = getCardKey(selectedCard.num);
                                                                                setAnalyzingCards(prev => ({ ...prev, [analyzeKey]: true }));
                                                                                try {
                                                                                    const newAnalysis = await reanalyzeCardValue(selectedCard.num, variant);
                                                                                    if (newAnalysis) {
                                                                                        setCollection(prevCollection => {
                                                                                            const updatedCollection = JSON.parse(JSON.stringify(prevCollection));
                                                                                            if (!updatedCollection[cardKey]) updatedCollection[cardKey] = {};
                                                                                            if (!updatedCollection[cardKey]._analyses) updatedCollection[cardKey]._analyses = {};
                                                                                            if (!updatedCollection[cardKey]._analyses[variant]) updatedCollection[cardKey]._analyses[variant] = [];
                                                                                            updatedCollection[cardKey]._analyses[variant].push({
                                                                                                id: Date.now(),
                                                                                                addedDate: new Date().toISOString(),
                                                                                                analysis: newAnalysis,
                                                                                                source: 'opus'
                                                                                            });
                                                                                            trimAnalyses(updatedCollection, 3);
                                                                                            localStorage.setItem('f1-collection-pro-v2', JSON.stringify(updatedCollection));
                                                                                            const mongoData = stripMetadataForMongo(updatedCollection);
                                                                                            fetch(`https://f1-card-tracker-backend-1.onrender.com/api/collection/cincymed-f1-collection`, {
                                                                                                method: 'POST',
                                                                                                headers: getAuthHeaders(),
                                                                                                body: JSON.stringify({ cards: mongoData })
                                                                                            }).catch(err => console.error('MongoDB sync error:', err));
                                                                                            return updatedCollection;
                                                                                        });
                                                                                    }
                                                                                } catch (error) {
                                                                                    console.error('Analysis error:', error);
                                                                                } finally {
                                                                                    setAnalyzingCards(prev => {
                                                                                        const updated = { ...prev };
                                                                                        delete updated[analyzeKey];
                                                                                        return updated;
                                                                                    });
                                                                                }
                                                                            }}
                                                                            disabled={isAnalyzing}
                                                                            className={`bg-purple-600 hover:bg-purple-700 text-white rounded font-semibold disabled:opacity-50 ${isMobile ? 'px-3 py-2 text-sm' : 'px-4 py-2 text-sm'}`}
                                                                            title="Analyze value with Opus model"
                                                                        >
                                                                            {isAnalyzing ? 'âŸ³' : 'ðŸ”'} Opus
                                                                        </button>
                                                                        <button
                                                                            onClick={(e) => {
                                                                                e.stopPropagation();
                                                                                setGradeCardContext({ cardNum: selectedCard.num, variant });
                                                                                setShowGradeCamera(true);
                                                                            }}
                                                                            disabled={isAnalyzing}
                                                                            className={`bg-amber-600 hover:bg-amber-700 text-white rounded font-semibold disabled:opacity-50 ${isMobile ? 'px-3 py-2 text-sm' : 'px-4 py-2 text-sm'}`}
                                                                            title="Quick Grade Assessment"
                                                                        >
                                                                            {isAnalyzing ? 'âŸ³' : 'ðŸ“Š'} Quick Grade
                                                                        </button>
                                                                    </div>
                                                                </div>
                                                                <div className="bg-slate-800/60 rounded-lg p-2.5 border border-slate-600/40 flex-shrink-0 flex flex-col">
                                                                    <div className="text-xs font-semibold text-slate-400 mb-1.5 uppercase tracking-wider">Add/Delete Card</div>
                                                                    <div className="flex items-center justify-center gap-3 flex-1">
                                                                        <button
                                                                            onClick={() => {
                                                                                if (!originalCardDetail) {
                                                                                    const key = getCardKey(selectedCard.num);
                                                                                    setOriginalCardDetail(JSON.parse(JSON.stringify(collection[key])));
                                                                                }
                                                                                setCardDetailEdit(true);
                                                                                removeCard(selectedCard.num, variant);
                                                                            }}
                                                                            disabled={count === 0}
                                                                            title="Remove one card from collection"
                                                                            className={`bg-red-600 hover:bg-red-700 rounded-lg disabled:opacity-30 font-bold ${isMobile ? 'w-12 h-12 text-lg' : 'w-10 h-10'}`}
                                                                        >âˆ’</button>
                                                                        <span className={`text-center font-bold text-green-400 ${isMobile ? 'text-xl' : 'text-lg'}`} title="Number of this variant in your collection">{count}</span>
                                                                        <button
                                                                            onClick={() => {
                                                                                if (!originalCardDetail) {
                                                                                    const key = getCardKey(selectedCard.num);
                                                                                    setOriginalCardDetail(JSON.parse(JSON.stringify(collection[key] || {})));
                                                                                }
                                                                                setCardDetailEdit(true);
                                                                                addCard(selectedCard.num, variant);
                                                                            }}
                                                                            title="Add one card to collection"
                                                                            className={`bg-green-600 hover:bg-green-700 rounded-lg font-bold ${isMobile ? 'w-12 h-12 text-lg' : 'w-10 h-10'}`}
                                                                        >+</button>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                            
                                                            {/* Show analysis if available */}
                                                            {isAnalyzing && (
                                                                <div className="mt-2 text-xs text-slate-400 italic">
                                                                    âŸ³ Analyzing value...
                                                                </div>
                                                            )}
                                                            
                                                            {latestAnalysis && !isAnalyzing && count > 0 && (
                                                                <div className="mt-2 bg-blue-900/20 border border-blue-500/30 rounded p-3">
                                                                    <div className="mb-2">
                                                                        <button
                                                                            onClick={(e) => {
                                                                                e.stopPropagation();
                                                                                const collapseKey = `analysis-${selectedCard.num}-${variant}`;
                                                                                setCollapsedSections(prev => ({...prev, [collapseKey]: !prev[collapseKey]}));
                                                                            }}
                                                                            className="font-semibold text-blue-400 text-sm flex items-center gap-1 hover:text-blue-300 transition-colors"
                                                                        >
                                                                            ðŸ’Ž Card Value Analysis
                                                                            {latestAnalysis.source && (
                                                                                <span className={`text-xs px-1.5 py-0.5 rounded-full ml-1 ${
                                                                                    latestAnalysis.source === 'opus'
                                                                                        ? 'bg-purple-600/40 text-purple-300'
                                                                                        : 'bg-blue-600/40 text-blue-300'
                                                                                }`}>
                                                                                    {latestAnalysis.source === 'opus' ? 'Opus' : 'Sonnet'}
                                                                                </span>
                                                                            )}
                                                                            <span className="text-xs">{collapsedSections[`analysis-${selectedCard.num}-${variant}`] ? 'â–¼' : 'â–²'}</span>
                                                                        </button>
                                                                    </div>
                                                                    {!collapsedSections[`analysis-${selectedCard.num}-${variant}`] && (
                                                                        <>
                                                                            <div className="text-slate-300 leading-relaxed">{formatAnalysisText(latestAnalysis.analysis)}</div>
                                                                            <div className="text-xs text-slate-500 mt-2">
                                                                                Added: {new Date(latestAnalysis.addedDate).toLocaleDateString()}
                                                                            </div>
                                                                        </>
                                                                    )}
                                                                </div>
                                                            )}

                                                        {/* Quick Grade Assessment Section */}
                                                        {variant && collection[getCardKey(selectedCard.num)]?._gradeReports?.[variant] && (
                                                            <div className="mt-2 bg-blue-900/20 border border-blue-500/30 rounded p-3" data-testid="quick-grade-assessment">
                                                                <div className="flex justify-between items-center mb-3">
                                                                    <button 
                                                                        onClick={(e) => {
                                                                            e.stopPropagation();
                                                                            const collapseKey = `grade-${selectedCard.num}-${variant}`;
                                                                            setCollapsedSections(prev => ({...prev, [collapseKey]: !prev[collapseKey]}));
                                                                        }}
                                                                        className="font-semibold text-blue-400 text-sm flex items-center gap-1 hover:text-blue-300 transition-colors"
                                                                    >
                                                                        ðŸ“Š Quick Grade Assessment
                                                                        <span className="text-xs">{collapsedSections[`grade-${selectedCard.num}-${variant}`] ? 'â–¼' : 'â–²'}</span>
                                                                    </button>
                                                                </div>
                                                                {!collapsedSections[`grade-${selectedCard.num}-${variant}`] && (
                                                                    <div className="text-slate-300 leading-relaxed">
                                                                        {formatQuickGradeReport(collection[getCardKey(selectedCard.num)]._gradeReports[variant])}
                                                                    </div>
                                                                )}
                                                            </div>
                                                        )}
                                                    </div>
                                                );
                                                });
                                            })()}
                                        </div>

                                        {/* Add a Card Button */}
                                        <div className="mt-4 mb-2">
                                            <button
                                                onClick={async () => {
                                                    const cardNum = selectedCard.num.toString();
                                                    setManualCardData({ 
                                                        cardNumber: cardNum, 
                                                        variant: 'Base', 
                                                        serialNumber: '',
                                                        cardTitle: '',
                                                        driverName: '',
                                                        value: ''
                                                    });
                                                    setShowAddCardManual(true);
                                                    
                                                    // Fetch card details in the background
                                                    const details = await lookupCardDetails(cardNum);
                                                    if (details) {
                                                        setManualCardData(prev => ({
                                                            ...prev,
                                                            cardTitle: details.cardTitle || '',
                                                            driverName: details.driverName || '',
                                                            value: details.value || ''
                                                        }));
                                                    }
                                                }}
                                                className="w-full bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 text-white py-3 px-4 rounded-lg font-semibold text-sm transition-all shadow-lg"
                                            >
                                                âž• Add a Card
                                            </button>
                                        </div>

                                        {/* Add New Variant Section */}
                                        <div className="mt-6 pt-6 border-t border-slate-700">
                                            <h4 className="text-sm font-semibold text-slate-300 mb-3">âž• Add New Card Variant</h4>
                                            <p className="text-xs text-slate-400 mb-3">Don't see a variant you want to add? Select from the list below:</p>
                                            <select
                                                className="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg text-sm focus:border-blue-500 focus:outline-none mb-3"
                                                title="Select a variant to add"
                                                onChange={(e) => {
                                                    if (e.target.value) {
                                                        // Track original state before first change
                                                        if (!originalCardDetail) {
                                                            const key = getCardKey(selectedCard.num);
                                                            setOriginalCardDetail(JSON.parse(JSON.stringify(collection[key] || {})));
                                                        }
                                                        setCardDetailEdit(true);
                                                        addCard(selectedCard.num, e.target.value);
                                                        e.target.value = '';  // Reset dropdown
                                                    }
                                                }}
                                                defaultValue=""
                                            >
                                                <option value="">Select a variant...</option>
                                                {(() => {
                                                    const cardKey = getCardKey(selectedCard.num);
                                                    const cardInventory = collection[cardKey] || {};
                                                    return OFFICIAL_VARIANTS
                                                        .filter(v => !(cardInventory[v] > 0))  // Only show variants not in collection
                                                        .map(variant => {
                                                            const count = cardInventory[variant] || 0;
                                                            return (
                                                                <option key={variant} value={variant}>{variant}{count > 0 ? ` (${count})` : ''}</option>
                                                            );
                                                        });
                                                })()}
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {showImageUpload && (
                            <div className="fixed inset-0 bg-black/80 flex items-center justify-center p-4 z-50"
                                onClick={() => {
                                    stopScannerCamera();
                                    setScannerCapturedImages([]);
                                    setScannerMode('camera');
                                    setShowImageUpload(false);
                                    setUploadedImages([]);
                                    setPendingImages([]);
                                    setShowSecondImagePrompt(false);
                                    setRecognizedCard(null);
                                    setEditedCard(null);
                                    setIsEditing(false);
                                    setRecognitionError(null);
                                    setDeepAnalysis(null);
                                    setSelectedAnalysisSource('opus');
                                }}>
                                <div className={`bg-slate-800 rounded-2xl p-6 ${isMobile ? 'w-full max-h-[95vh]' : 'max-w-4xl w-full max-h-[90vh]'} overflow-y-auto scrollbar-hide`} onClick={(e) => e.stopPropagation()}>
                                    <div className="flex justify-between items-center mb-6">
                                        <h2 className="text-2xl font-bold">ðŸ“· AI Scanner</h2>
                                        <button
                                            onClick={() => {
                                                stopScannerCamera();
                                                setScannerCapturedImages([]);
                                                setScannerMode('camera');
                                                setShowImageUpload(false);
                                                setUploadedImages([]);
                                                setPendingImages([]);
                                                setShowSecondImagePrompt(false);
                                                setRecognizedCard(null);
                                                setEditedCard(null);
                                                setIsEditing(false);
                                                setRecognitionError(null);
                                                setDeepAnalysis(null);
                                                setSelectedAnalysisSource('opus');
                                            }}
                                            className="bg-red-600 hover:bg-red-700 text-white rounded-lg font-semibold px-4 py-2 text-sm"
                                            title="Close scanner"
                                        >
                                            âœ• Cancel
                                        </button>
                                    </div>

                                    {/* Mobile Debug Panel - Commented out, can be re-enabled if needed
                                    {isMobile && (
                                        <div className="mb-4 bg-yellow-900/20 border border-yellow-500/30 rounded-lg p-3">
                                            <details className="text-xs text-yellow-300">
                                                <summary className="cursor-pointer font-semibold mb-2">ðŸ” Mobile Debug Info</summary>
                                                <div className="space-y-1 mt-2" id="mobile-debug-status">
                                                    <div>Local Storage: <span id="debug-storage-status">{localStorage.getItem('f1Collection') ? 'EXISTS' : 'EMPTY'}</span></div>
                                                    <div>Collection Size: <span id="debug-collection-size">{Object.keys(collection || {}).length}</span> cards</div>
                                                    <div>Auth Token: <span id="debug-auth-status">{localStorage.getItem('authToken') ? 'SET' : 'MISSING'}</span></div>
                                                    <div>Last Sync: <span id="debug-sync-status">{localStorage.getItem('lastSync') || 'NEVER'}</span></div>
                                                    <div>Recognition Error: {recognitionError || 'NONE'}</div>
                                                    <div>Network: {navigator.onLine ? 'ONLINE' : 'OFFLINE'}</div>
                                                    <div>Recognized Card: {recognizedCard?.name || 'NONE'}</div>
                                                    <div>Server Online: {serverOnline ? 'YES' : 'NO'}</div>
                                                    <div>Browser: <span id="debug-browser-info">{navigator.userAgent.includes('Safari') ? 'Safari' : 'Other'}</span></div>
                                                </div>
                                                <div className="flex gap-2 mt-3">
                                                    <button
                                                        onClick={() => {
                                                            const refreshDebugDisplay = () => {
                                                                document.getElementById('debug-storage-status').textContent =
                                                                    localStorage.getItem('f1Collection') ? 'EXISTS' : 'EMPTY';
                                                                document.getElementById('debug-auth-status').textContent =
                                                                    localStorage.getItem('authToken') ? 'SET' : 'MISSING';
                                                                document.getElementById('debug-sync-status').textContent =
                                                                    localStorage.getItem('lastSync') || 'NEVER';

                                                                const stored = localStorage.getItem('f1Collection');
                                                                if (stored) {
                                                                    try {
                                                                        const parsed = JSON.parse(stored);
                                                                        document.getElementById('debug-collection-size').textContent =
                                                                            Object.keys(parsed || {}).length;
                                                                    } catch (e) {
                                                                        document.getElementById('debug-collection-size').textContent = 'ERROR';
                                                                    }
                                                                }
                                                            };

                                                            let results = [];

                                                            try {
                                                                localStorage.setItem('test', 'working');
                                                                const retrieved = localStorage.getItem('test');
                                                                if (retrieved === 'working') {
                                                                    results.push('âœ… localStorage: WORKING');
                                                                    localStorage.removeItem('test');
                                                                } else {
                                                                    results.push('âŒ localStorage: READ FAILED');
                                                                }
                                                            } catch (error) {
                                                                results.push(`âŒ localStorage: ERROR - ${error.message}`);
                                                            }

                                                            const collectionKeys = Object.keys(collection || {});
                                                            results.push(`ðŸ“Š Collection in React: ${collectionKeys.length} cards`);

                                                            const stored = localStorage.getItem('f1Collection');
                                                            if (stored) {
                                                                try {
                                                                    const parsed = JSON.parse(stored);
                                                                    results.push(`ðŸ“Š Collection in Storage: ${Object.keys(parsed).length} cards`);
                                                                } catch (e) {
                                                                    results.push('âŒ Storage data corrupted');
                                                                }
                                                            } else {
                                                                results.push('ðŸ“Š Collection in Storage: 0 cards (empty)');
                                                            }

                                                            if ('storage' in navigator && 'estimate' in navigator.storage) {
                                                                results.push('âœ… Not in private mode');
                                                            } else {
                                                                results.push('âš ï¸ Possibly private mode');
                                                            }

                                                            alert(results.join('\n\n'));
                                                            refreshDebugDisplay();
                                                        }}
                                                        className="bg-yellow-600 hover:bg-yellow-700 text-black text-xs px-2 py-1 rounded"
                                                    >
                                                        Full Test
                                                    </button>
                                                    <button
                                                        onClick={() => {
                                                            try {
                                                                const collectionData = JSON.stringify(collection);
                                                                localStorage.setItem('f1Collection', collectionData);

                                                                document.getElementById('debug-storage-status').textContent = 'EXISTS';
                                                                document.getElementById('debug-collection-size').textContent =
                                                                    Object.keys(collection || {}).length;

                                                                alert(`Force Save: SUCCESS\n\nSize: ${collectionData.length} chars\nCards: ${Object.keys(collection || {}).length}`);
                                                            } catch (error) {
                                                                alert(`Force Save: FAILED\n\nError: ${error.message}`);
                                                            }
                                                        }}
                                                        className="bg-blue-600 hover:bg-blue-700 text-white text-xs px-2 py-1 rounded"
                                                    >
                                                        Force Save
                                                    </button>
                                                    <button
                                                        onClick={() => {
                                                            const stored = localStorage.getItem('f1Collection');
                                                            if (stored) {
                                                                try {
                                                                    const parsed = JSON.parse(stored);
                                                                    alert(`âœ… STORAGE LOAD TEST\n\nStored: ${Object.keys(parsed).length} cards\nIn React: ${Object.keys(collection || {}).length} cards\n\n${Object.keys(parsed).length !== Object.keys(collection || {}).length ? 'âš ï¸ MISMATCH - App not loading from storage!' : 'âœ… Match - App loading correctly'}`);
                                                                } catch (e) {
                                                                    alert('âŒ Storage data corrupted');
                                                                }
                                                            } else {
                                                                alert('âŒ No data in localStorage');
                                                            }
                                                        }}
                                                        className="bg-green-600 hover:bg-green-700 text-white text-xs px-2 py-1 rounded"
                                                    >
                                                        Test Load
                                                    </button>
                                                </div>
                                            </details>
                                        </div>
                                    )}
                                    End of Mobile Debug Panel */}
                                    
                                    <input ref={fileInputRef} type="file" accept="image/*" onChange={handleImageUpload} multiple className="hidden" />

                                    <>
                                    {!uploadedImages || uploadedImages.length === 0 && !recognizedCard ? (
                                        <>
                                            {/* Mode toggle: Camera vs Upload */}
                                            <div className="flex gap-2 mb-4">
                                                <button
                                                    onClick={() => setScannerMode('camera')}
                                                    className={`flex-1 py-2 rounded-lg text-sm font-semibold transition-all ${scannerMode === 'camera' ? 'bg-blue-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}`}
                                                >
                                                    ðŸ“· Camera
                                                </button>
                                                <button
                                                    onClick={() => { stopScannerCamera(); setScannerMode('upload'); }}
                                                    className={`flex-1 py-2 rounded-lg text-sm font-semibold transition-all ${scannerMode === 'upload' ? 'bg-blue-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}`}
                                                >
                                                    ðŸ“ Upload Files
                                                </button>
                                            </div>

                                            {/* Camera selector - shown in camera mode when multiple cameras available */}
                                            {scannerMode === 'camera' && availableCameras.length > 1 && (
                                                <div className="mb-3 flex items-center gap-2">
                                                    <span className="text-xs text-slate-400 font-semibold flex-shrink-0">Camera:</span>
                                                    <select
                                                        value={selectedCameraId}
                                                        onChange={(e) => {
                                                            handleCameraChange(e.target.value);
                                                            // Restart camera if currently active
                                                            if (scannerCameraActive) {
                                                                stopScannerCamera();
                                                                setTimeout(() => startScannerCamera(), 300);
                                                            }
                                                        }}
                                                        className="flex-1 bg-slate-700 border border-slate-600 text-white text-xs rounded-lg px-2 py-1.5 focus:border-blue-500 focus:outline-none"
                                                    >
                                                        <option value="">Default Camera</option>
                                                        {availableCameras.map(cam => (
                                                            <option key={cam.deviceId} value={cam.deviceId}>
                                                                {cam.label || `Camera ${availableCameras.indexOf(cam) + 1}`}
                                                            </option>
                                                        ))}
                                                    </select>
                                                </div>
                                            )}

                                            {scannerMode === 'camera' ? (
                                                isMobile && scannerCameraActive ? (
                                                    /* Mobile full-screen camera view */
                                                    <div className="fixed inset-0 z-[200] bg-black flex flex-col">
                                                        {/* Full-screen video feed */}
                                                        <video ref={scannerVideoCallbackRef} autoPlay playsInline muted className="w-full h-full object-cover" />

                                                        {/* Top bar - close button, status, and camera selector */}
                                                        <div className="absolute top-0 left-0 right-0 p-3 bg-gradient-to-b from-black/70 to-transparent">
                                                            <div className="flex justify-between items-center">
                                                                <span className="text-white text-sm font-semibold bg-black/50 px-3 py-1 rounded-full">
                                                                    {scannerCapturedImages.length === 0 ? 'Capture Front' : 'Capture Back'}
                                                                </span>
                                                                <button
                                                                    onClick={() => { stopScannerCamera(); }}
                                                                    className="bg-red-600/80 hover:bg-red-700 text-white w-9 h-9 rounded-full flex items-center justify-center text-lg font-bold"
                                                                >
                                                                    âœ•
                                                                </button>
                                                            </div>
                                                            {availableCameras.length > 1 && (
                                                                <select
                                                                    value={selectedCameraId}
                                                                    onChange={(e) => {
                                                                        handleCameraChange(e.target.value);
                                                                        stopScannerCamera();
                                                                        setTimeout(() => startScannerCamera(), 300);
                                                                    }}
                                                                    className="mt-2 w-full bg-black/60 border border-white/30 text-white text-xs rounded-lg px-2 py-1.5 focus:outline-none"
                                                                >
                                                                    <option value="">Default Camera</option>
                                                                    {availableCameras.map(cam => (
                                                                        <option key={cam.deviceId} value={cam.deviceId}>
                                                                            {cam.label || `Camera ${availableCameras.indexOf(cam) + 1}`}
                                                                        </option>
                                                                    ))}
                                                                </select>
                                                            )}
                                                        </div>

                                                        {/* Captured thumbnails - floating top-left */}
                                                        {scannerCapturedImages.length > 0 && (
                                                            <div className="absolute top-14 left-3 flex gap-2">
                                                                {scannerCapturedImages.map((img, idx) => (
                                                                    <div key={idx} className="relative w-16 h-20 rounded-lg overflow-hidden border-2 border-white/50 shadow-lg">
                                                                        <img src={img} alt={idx === 0 ? 'Front' : 'Back'} className="w-full h-full object-cover" />
                                                                        <span className="absolute bottom-0 left-0 right-0 text-center text-[10px] bg-black/70 text-white py-0.5">{idx === 0 ? 'Front' : 'Back'}</span>
                                                                        <button
                                                                            onClick={() => removeScannerImage(idx)}
                                                                            className="absolute top-0 right-0 bg-red-600 text-white text-[10px] w-4 h-4 rounded-full flex items-center justify-center"
                                                                        >
                                                                            x
                                                                        </button>
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        )}

                                                        {/* Bottom controls - floating over camera */}
                                                        <div className="absolute bottom-0 left-0 right-0 p-4 pb-8 bg-gradient-to-t from-black/80 to-transparent">
                                                            <div className="flex items-center justify-center gap-4">
                                                                <button
                                                                    onClick={stopScannerCamera}
                                                                    className="bg-slate-600/80 hover:bg-slate-500 w-14 h-14 rounded-full flex items-center justify-center text-sm font-semibold shadow-lg"
                                                                >
                                                                    Stop
                                                                </button>
                                                                <button
                                                                    onClick={captureScannerPhoto}
                                                                    className="bg-white hover:bg-slate-200 w-20 h-20 rounded-full flex items-center justify-center shadow-lg border-4 border-white/30"
                                                                >
                                                                    <div className="bg-green-500 w-16 h-16 rounded-full flex items-center justify-center">
                                                                        <span className="text-white text-2xl">ðŸ“¸</span>
                                                                    </div>
                                                                </button>
                                                                {scannerCapturedImages.length > 0 && (
                                                                    <button
                                                                        onClick={submitScannerImages}
                                                                        className="bg-green-600/80 hover:bg-green-700 w-14 h-14 rounded-full flex items-center justify-center text-[10px] font-bold shadow-lg text-center leading-tight"
                                                                    >
                                                                        Done
                                                                    </button>
                                                                )}
                                                            </div>
                                                            <p className="text-center text-white/60 text-xs mt-3">
                                                                {scannerCapturedImages.length === 0 ? 'Position the front of the card in frame' : scannerCapturedImages.length === 1 ? 'Now capture the back (card number)' : 'Ready to analyze'}
                                                            </p>
                                                        </div>
                                                    </div>
                                                ) : (
                                                <div className="space-y-3">
                                                    {/* Camera viewfinder - desktop or mobile camera not yet started */}
                                                    <div className={`bg-slate-900 rounded-xl overflow-hidden relative ${isMobile ? 'h-64' : 'h-80'}`}>
                                                        {scannerCameraActive ? (
                                                            <video ref={scannerVideoCallbackRef} autoPlay playsInline muted className="w-full h-full object-contain" />
                                                        ) : (
                                                            <div className="w-full h-full flex flex-col items-center justify-center">
                                                                <span className="text-7xl mb-3">ðŸ“·</span>
                                                                <span className="text-slate-400 text-sm font-semibold">Camera not started</span>
                                                                <button
                                                                    onClick={startScannerCamera}
                                                                    className="mt-4 bg-blue-600 hover:bg-blue-700 px-6 py-3 rounded-lg font-semibold text-sm"
                                                                >
                                                                    Start Camera
                                                                </button>
                                                            </div>
                                                        )}
                                                    </div>

                                                    {/* Camera controls - desktop */}
                                                    {scannerCameraActive && (
                                                        <div className="flex gap-2">
                                                            <button
                                                                onClick={captureScannerPhoto}
                                                                className="flex-1 bg-green-600 hover:bg-green-700 py-3 rounded-lg font-semibold text-sm"
                                                            >
                                                                ðŸ“¸ Capture {scannerCapturedImages.length === 0 ? 'Front' : 'Back'}
                                                            </button>
                                                            <button
                                                                onClick={stopScannerCamera}
                                                                className="bg-slate-600 hover:bg-slate-500 px-4 py-3 rounded-lg text-sm font-semibold"
                                                            >
                                                                Stop
                                                            </button>
                                                        </div>
                                                    )}

                                                    {/* Captured image previews */}
                                                    {scannerCapturedImages.length > 0 && (
                                                        <div className="space-y-2">
                                                            <div className="text-xs text-slate-400 font-semibold">
                                                                Captured: {scannerCapturedImages.length}/2 images {scannerCapturedImages.length === 1 ? '(capture back next)' : ''}
                                                            </div>
                                                            <div className="grid grid-cols-2 gap-2">
                                                                {scannerCapturedImages.map((img, idx) => (
                                                                    <div key={idx} className="relative">
                                                                        <img src={img} alt={idx === 0 ? 'Front' : 'Back'} className="w-full h-24 object-contain bg-slate-800 rounded-lg" />
                                                                        <span className="absolute top-1 left-1 text-xs bg-black/60 px-1.5 py-0.5 rounded">{idx === 0 ? 'Front' : 'Back'}</span>
                                                                        <button
                                                                            onClick={() => removeScannerImage(idx)}
                                                                            className="absolute top-1 right-1 bg-red-600 hover:bg-red-700 text-white text-xs w-5 h-5 rounded-full flex items-center justify-center"
                                                                        >
                                                                            x
                                                                        </button>
                                                                    </div>
                                                                ))}
                                                            </div>
                                                            {scannerCapturedImages.length === 1 && !scannerCameraActive && (
                                                                <div className="flex gap-2">
                                                                    <button
                                                                        onClick={startScannerCamera}
                                                                        className="flex-1 bg-blue-600 hover:bg-blue-700 py-2 rounded-lg text-sm font-semibold"
                                                                    >
                                                                        ðŸ“· Capture Back
                                                                    </button>
                                                                    <button
                                                                        onClick={submitScannerImages}
                                                                        className="flex-1 bg-green-600 hover:bg-green-700 py-2 rounded-lg text-sm font-semibold"
                                                                    >
                                                                        Proceed with 1 Image
                                                                    </button>
                                                                </div>
                                                            )}
                                                        </div>
                                                    )}

                                                    <div className="bg-blue-900/20 border border-blue-500/30 rounded-lg p-3">
                                                        <p className="text-xs text-slate-300">
                                                            <strong>Tip:</strong> Capture the <strong>front</strong> first, then the <strong>back</strong> (card number). Good lighting helps!
                                                        </p>
                                                    </div>
                                                </div>
                                                )
                                            ) : (
                                                <>
                                                    <button onClick={() => fileInputRef.current?.click()} className={`w-full border-2 border-dashed border-slate-600 rounded-xl flex flex-col items-center justify-center hover:border-blue-500 transition-colors bg-slate-900/50 ${isMobile ? 'h-48' : 'h-80'}`}>
                                                        <span className={`text-slate-300 mb-3 font-semibold ${isMobile ? 'text-sm' : 'text-base'}`}>ðŸ“¸ Upload Card Images</span>
                                                        <span className="text-7xl mb-3">ðŸ“</span>
                                                        <span className="text-slate-400 text-sm text-center px-4 font-semibold">Upload BOTH front and back images</span>
                                                        <span className="text-slate-500 text-xs text-center px-4 mt-2">The back image's card number guides AI analysis</span>
                                                    </button>
                                                    <div className="bg-blue-900/20 border border-blue-500/30 rounded-lg p-4 mt-4">
                                                        <p className="text-sm font-semibold text-blue-400 mb-2">
                                                            âœ¨ How to Get Best Results:
                                                        </p>
                                                        <ul className="text-xs text-slate-300 space-y-1">
                                                            <li>âœ“ <strong>Upload 2 images:</strong> First the front, then the back</li>
                                                            <li>âœ“ <strong>Back image is crucial:</strong> Contains the card number</li>
                                                            <li>âœ“ <strong>Good lighting:</strong> Ensures card details are visible</li>
                                                        </ul>
                                                    </div>
                                                </>
                                            )}
                                        </>
                                    ) : (!uploadedImages || uploadedImages.length === 0) && recognizedCard ? (
                                        <div className="space-y-4">
                                            <div className="relative bg-slate-900 rounded-xl p-8 flex items-center justify-center h-80">
                                                <div className="text-center">
                                                    <img src="logo.png" alt="F1 Card Tracker" className="w-24 h-24 mx-auto mb-4 rounded-xl" />
                                                    <p className="text-slate-400 text-lg font-semibold">2025 Topps Chrome F1</p>
                                                    <p className="text-slate-500 text-sm mt-2">No image available</p>
                                                    <button 
                                                        onClick={() => fileInputRef.current?.click()} 
                                                        className="mt-4 bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg text-sm font-semibold"
                                                    >
                                                        ðŸ“· Upload Image
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    ) : uploadedImages && uploadedImages.length > 0 ? (
                                        <div className="space-y-4">
                                            {/* Show all uploaded images */}
                                            <div className={`grid ${isMobile ? 'grid-cols-1' : uploadedImages.length > 1 ? 'grid-cols-2' : 'grid-cols-1'} gap-4`}>
                                                {uploadedImages.map((img, idx) => (
                                                    <div key={idx} className="relative group cursor-pointer" onClick={() => {
                                                        setCurrentImageIndex(idx);
                                                        setImageViewerZoom(1);
                                                        setImageViewerPosition({ x: 0, y: 0 });
                                                        setShowImageViewer(true);
                                                    }}>
                                                        <img src={img} alt={`Card image ${idx + 1}`} className="w-full max-h-96 object-contain bg-slate-900 rounded-xl" />
                                                        <div className="absolute inset-0 bg-black/0 group-hover:bg-black/50 transition-all rounded-xl flex items-center justify-center opacity-0 group-hover:opacity-100">
                                                            <span className="text-white text-lg font-semibold">ðŸ” Click to enlarge</span>
                                                        </div>
                                                        <div className="absolute top-2 left-2 bg-black/70 text-white text-xs px-2 py-1 rounded">
                                                            {uploadedImages.length === 2 ? (idx === 0 ? 'Front' : 'Back') : `Image ${idx + 1}/${uploadedImages.length}`}
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                            
                                            {isRecognizing && (
                                                <div className="text-center py-8 bg-slate-900/50 rounded-xl">
                                                    <div className="animate-spin text-5xl mb-4">âŸ³</div>
                                                    <p className="text-slate-300">AI analyzing card...</p>
                                                    <p className="text-xs text-slate-400 mt-2">This may take 5-10 seconds</p>
                                                </div>
                                            )}
                                            
                                            {recognitionError && (
                                                <div className="bg-red-900/20 border border-red-500/30 rounded-lg p-4">
                                                    <p className="text-red-300 font-semibold mb-2">Recognition Error</p>
                                                    <p className="text-sm text-red-200 mb-3">{recognitionError}</p>
                                                    <button
                                                        onClick={() => {
                                                            setUploadedImages([]);
                                                            setPendingImages([]);
                                                            setScannerCapturedImages([]);
                                                            setShowSecondImagePrompt(false);
                                                            setRecognitionError(null);
                                                            setDeepAnalysis(null);
                                                            setSelectedAnalysisSource('opus');
                                                        }}
                                                        className="w-full bg-red-600 hover:bg-red-700 px-4 py-2 rounded-lg text-sm mb-2"
                                                    >
                                                        Try Different Photo
                                                    </button>
                                                    <p className="text-xs text-red-300">
                                                        ðŸ’¡ Tips: Ensure card number is clearly visible, good lighting, try a different angle
                                                    </p>
                                                </div>
                                            )}
                                        </div>
                                    ) : null}
                                    
                                    {recognizedCard && (
                                        <div className="space-y-4">
                                            {/* Action Buttons - Above Card Analyzed Section */}
                                            <div className={isMobile ? 'space-y-2' : 'flex gap-2 flex-wrap'}>
                                                {/* Row 1: Re-analyze + Quick Grade */}
                                                <div className={`flex gap-2 ${isMobile ? 'w-full' : ''}`}>
                                                    <button
                                                        onClick={performDeepAnalysis}
                                                        disabled={isDeepAnalyzing}
                                                        className={`rounded-lg font-semibold bg-purple-600 hover:bg-purple-700 disabled:opacity-50 ${isMobile ? 'flex-1 py-2 text-sm' : 'px-4 py-2 text-sm'}`}
                                                    >
                                                        {isDeepAnalyzing ? 'âŸ³ Analyzing...' : 'ðŸ” Re-analyze'}
                                                    </button>
                                                    <button
                                                        onClick={performQuickGrade}
                                                        disabled={isDeepAnalyzing}
                                                        className={`rounded-lg font-semibold bg-amber-600 hover:bg-amber-700 disabled:opacity-50 ${isMobile ? 'flex-1 py-2 text-sm' : 'px-4 py-2 text-sm'}`}
                                                    >
                                                        {isDeepAnalyzing ? 'âŸ³ Grading...' : 'ðŸ“Š Quick Grade'}
                                                    </button>
                                                </div>
                                                
                                                {/* Row 2: Edit, Cancel, Add */}
                                                {isMobile && (
                                                    <div className="flex gap-2 w-full">
                                                        <button
                                                            onClick={() => {
                                                                if (isEditing) {
                                                                    handleDoneEditing();
                                                                } else {
                                                                    setIsEditing(true);
                                                                    setEditedCard({...recognizedCard});
                                                                }
                                                            }}
                                                            className={`flex-1 py-2 rounded-lg text-sm font-semibold ${
                                                                isEditing ? 'bg-green-600 hover:bg-green-700' : 'bg-blue-600 hover:bg-blue-700'
                                                            }`}
                                                        >
                                                            {isEditing ? 'âœ“ Done' : 'âœŽ Edit'}
                                                        </button>
                                                        <button
                                                            onClick={() => {
                                                                setShowImageUpload(false);
                                                                setUploadedImages([]);
                                                                setPendingImages([]);
                                                                setScannerCapturedImages([]);
                                                                setShowSecondImagePrompt(false);
                                                                setRecognizedCard(null);
                                                                setEditedCard(null);
                                                                setIsEditing(false);
                                                                setRecognitionError(null);
                                                                setDeepAnalysis(null);
                                                                setSelectedAnalysisSource('opus');
                                                            }}
                                                            className="flex-1 py-2 rounded-lg text-sm font-semibold bg-slate-600 hover:bg-slate-700"
                                                        >
                                                            âœ• Cancel
                                                        </button>
                                                        <button
                                                            onClick={handleAddRecognizedCard}
                                                            disabled={addCardCooldown > 0}
                                                            className={`flex-1 py-2 rounded-lg text-sm font-semibold transition-all ${
                                                                addCardCooldown > 0 
                                                                    ? 'bg-gray-600 text-gray-300 cursor-not-allowed opacity-50' 
                                                                    : 'bg-green-600 hover:bg-green-700'
                                                            }`}
                                                            title={addCardCooldown > 0 ? `Wait ${addCardCooldown}s before adding another card` : 'Add card to collection'}
                                                        >
                                                            {addCardCooldown > 0 ? `â±ï¸ ${addCardCooldown}s` : 'âœ“ Add'}
                                                        </button>
                                                    </div>
                                                )}
                                                
                                                {/* Desktop buttons - single row */}
                                                {!isMobile && (
                                                    <>
                                                        <button
                                                            onClick={() => {
                                                                if (isEditing) {
                                                                    handleDoneEditing();
                                                                } else {
                                                                    setIsEditing(true);
                                                                    setEditedCard({...recognizedCard});
                                                                }
                                                            }}
                                                            className={`px-4 py-2 rounded-lg text-sm font-semibold ${
                                                                isEditing ? 'bg-green-600 hover:bg-green-700' : 'bg-blue-600 hover:bg-blue-700'
                                                            }`}
                                                        >
                                                            {isEditing ? 'âœ“ Done' : 'âœŽ Edit'}
                                                        </button>
                                                        <button
                                                            onClick={() => {
                                                                setShowImageUpload(false);
                                                                setUploadedImages([]);
                                                                setPendingImages([]);
                                                                setScannerCapturedImages([]);
                                                                setShowSecondImagePrompt(false);
                                                                setRecognizedCard(null);
                                                                setEditedCard(null);
                                                                setIsEditing(false);
                                                                setRecognitionError(null);
                                                                setDeepAnalysis(null);
                                                                setSelectedAnalysisSource('opus');
                                                            }}
                                                            className="px-4 py-2 rounded-lg text-sm font-semibold bg-slate-600 hover:bg-slate-700"
                                                        >
                                                            âœ• Cancel
                                                        </button>
                                                        <button
                                                            onClick={handleAddRecognizedCard}
                                                            disabled={addCardCooldown > 0}
                                                            className={`px-4 py-2 rounded-lg text-sm font-semibold transition-all ${
                                                                addCardCooldown > 0 
                                                                    ? 'bg-gray-600 text-gray-300 cursor-not-allowed opacity-50' 
                                                                    : 'bg-green-600 hover:bg-green-700'
                                                            }`}
                                                            title={addCardCooldown > 0 ? `Wait ${addCardCooldown}s before adding another card` : 'Add card to collection'}
                                                        >
                                                            {addCardCooldown > 0 ? `â±ï¸ Wait ${addCardCooldown}s` : 'âœ“ Done'}
                                                        </button>
                                                    </>
                                                )}
                                            </div>
                                            
                                            <div className="bg-gradient-to-br from-green-900/20 to-blue-900/20 border border-green-500/30 rounded-xl p-5">
                                                <div className="flex justify-between items-center mb-4">
                                                    <h3 className="font-semibold text-lg">âœ¨ Card Analyzed</h3>
                                                </div>
                                        
                                        <div className="grid grid-cols-2 gap-3 p-4 bg-slate-900/50 rounded-lg">
                                            <div className={needsVerification(recognizedCard.cardNumberConfidence) ? 'needs-verification rounded p-2' : ''}>
                                                <span className="text-xs text-slate-400 flex items-center gap-1">
                                                    Card #
                                                    {needsVerification(recognizedCard.cardNumberConfidence) && (
                                                        <span className="text-yellow-400">âš ï¸</span>
                                                    )}
                                                    {recognizedCard._differences?.cardNumber && (
                                                        <span className="text-purple-400" title="Opus updated this value">ðŸ”</span>
                                                    )}
                                                </span>
                                                {isEditing ? (
                                                    <input
                                                        type="text"
                                                        value={editedCard.cardNumber}
                                                        onChange={(e) => {
                                                            const newValue = e.target.value;
                                                            setEditedCard({...editedCard, cardNumber: newValue});
                                                            // Mark as manually entered
                                                            setManualCardNumber(newValue);
                                                        }}
                                                        onBlur={(e) => {
                                                            const newValue = e.target.value;
                                                            if (newValue !== recognizedCard.cardNumber && uploadedImages && !isDeepAnalyzing) {
                                                                // Trigger Opus re-analysis
                                                                setTimeout(() => performDeepAnalysis(), 100);
                                                            }
                                                        }}
                                                        className="w-full bg-slate-800 border border-slate-600 rounded px-2 py-1 text-sm mt-1"
                                                    />
                                                ) : (
                                                    <div>
                                                        <p className="font-bold">{recognizedCard.cardNumber}</p>
                                                        {recognizedCard._differences?.cardNumber && (
                                                            <div className="text-xs text-slate-500 mt-1">
                                                                <span className="line-through">Sonnet: {recognizedCard.cardNumber}</span>
                                                                <br/>
                                                                <span className="text-purple-400">Opus: {recognizedCard._opusData.cardNumber}</span>
                                                            </div>
                                                        )}
                                                    </div>
                                                )}
                                            </div>
                                            <div className="bg-yellow-900/20 border border-yellow-500/30 rounded p-2">
                                                <span className="text-xs text-yellow-400 flex items-center gap-1">
                                                    ðŸ† Serial #
                                                    {recognizedCard._differences?.serialNumber && (
                                                        <span className="text-purple-400" title="Opus updated this value">ðŸ”</span>
                                                    )}
                                                </span>
                                                {isEditing ? (
                                                    <input
                                                        type="text"
                                                        value={editedCard.serialNumber || ''}
                                                        onChange={(e) => setEditedCard({...editedCard, serialNumber: e.target.value})}
                                                        placeholder="e.g., 63/250 or N/A"
                                                        className="w-full bg-slate-800 border border-slate-600 rounded px-2 py-1 text-sm mt-1 text-yellow-300 font-bold"
                                                    />
                                                ) : (
                                                    <div>
                                                        <p className="font-bold text-yellow-300">{recognizedCard.serialNumber || 'N/A'}</p>
                                                        {recognizedCard._differences?.serialNumber && (
                                                            <div className="text-xs text-slate-500 mt-1">
                                                                <span className="line-through">Sonnet: {recognizedCard.serialNumber || 'N/A'}</span>
                                                                <br/>
                                                                <span className="text-purple-400">Opus: {recognizedCard._opusData.serialNumber || 'N/A'}</span>
                                                                </div>
                                                            )}
                                                        </div>
                                                    )}
                                                </div>
                                            <div>
                                                <span className="text-xs text-slate-400 flex items-center gap-1">
                                                    Driver
                                                    {recognizedCard._differences?.driverName && (
                                                        <span className="text-purple-400" title="Opus updated this value">ðŸ”</span>
                                                    )}
                                                </span>
                                                {isEditing ? (
                                                    <div className="space-y-2">
                                                        {recognizedCard._differences?.driverName && recognizedCard._opusData ? (
                                                            <div className="space-y-2">
                                                                <div className="text-xs text-slate-400 mb-1">Select detected value:</div>
                                                                <label className="flex items-center gap-2 p-2 bg-slate-800 border border-slate-600 rounded cursor-pointer hover:bg-slate-700">
                                                                    <input
                                                                        type="radio"
                                                                        name="driverName"
                                                                        checked={editedCard.driverName === recognizedCard.driverName}
                                                                        onChange={() => setEditedCard({...editedCard, driverName: recognizedCard.driverName})}
                                                                    />
                                                                    <span className="text-sm">âš¡ Sonnet: {recognizedCard.driverName}</span>
                                                                </label>
                                                                <label className="flex items-center gap-2 p-2 bg-slate-800 border border-slate-600 rounded cursor-pointer hover:bg-slate-700">
                                                                    <input
                                                                        type="radio"
                                                                        name="driverName"
                                                                        checked={editedCard.driverName === recognizedCard._opusData.driverName}
                                                                        onChange={() => setEditedCard({...editedCard, driverName: recognizedCard._opusData.driverName})}
                                                                    />
                                                                    <span className="text-sm">ðŸ” Opus: {recognizedCard._opusData.driverName}</span>
                                                                </label>
                                                                <div className="text-xs text-slate-500">Or type custom:</div>
                                                            </div>
                                                        ) : null}
                                                        <input
                                                            type="text"
                                                            value={editedCard.driverName}
                                                            onChange={(e) => setEditedCard({...editedCard, driverName: e.target.value})}
                                                            className="w-full bg-slate-800 border border-slate-600 rounded px-2 py-1 text-sm mt-1"
                                                        />
                                                    </div>
                                                ) : (
                                                    <div>
                                                        <p className="font-bold">{recognizedCard.driverName}</p>
                                                        {recognizedCard._differences?.driverName && (
                                                            <div className="text-xs text-slate-500 mt-1">
                                                                <span className="line-through">Sonnet: {recognizedCard.driverName}</span>
                                                                <br/>
                                                                <span className="text-purple-400">Opus: {recognizedCard._opusData.driverName}</span>
                                                            </div>
                                                        )}
                                                    </div>
                                                )}
                                            </div>
                                            <div>
                                                <span className="text-xs text-slate-400 flex items-center gap-1">
                                                    Team
                                                    {recognizedCard._differences?.team && (
                                                        <span className="text-purple-400" title="Opus updated this value">ðŸ”</span>
                                                    )}
                                                </span>
                                                {isEditing ? (
                                                    <div className="space-y-2">
                                                        {recognizedCard._differences?.team && recognizedCard._opusData ? (
                                                            <div className="space-y-2">
                                                                <div className="text-xs text-slate-400 mb-1">Select detected value:</div>
                                                                <label className="flex items-center gap-2 p-2 bg-slate-800 border border-slate-600 rounded cursor-pointer hover:bg-slate-700">
                                                                    <input
                                                                        type="radio"
                                                                        name="team"
                                                                        checked={editedCard.team === recognizedCard.team}
                                                                        onChange={() => setEditedCard({...editedCard, team: recognizedCard.team})}
                                                                    />
                                                                    <span className="text-sm">âš¡ Sonnet: {recognizedCard.team}</span>
                                                                </label>
                                                                <label className="flex items-center gap-2 p-2 bg-slate-800 border border-slate-600 rounded cursor-pointer hover:bg-slate-700">
                                                                    <input
                                                                        type="radio"
                                                                        name="team"
                                                                        checked={editedCard.team === recognizedCard._opusData.team}
                                                                        onChange={() => setEditedCard({...editedCard, team: recognizedCard._opusData.team})}
                                                                    />
                                                                    <span className="text-sm">ðŸ” Opus: {recognizedCard._opusData.team}</span>
                                                                </label>
                                                                <div className="text-xs text-slate-500">Or type custom:</div>
                                                            </div>
                                                        ) : null}
                                                        <input
                                                            type="text"
                                                            value={editedCard.team}
                                                            onChange={(e) => setEditedCard({...editedCard, team: e.target.value})}
                                                            className="w-full bg-slate-800 border border-slate-600 rounded px-2 py-1 text-sm mt-1"
                                                        />
                                                    </div>
                                                ) : (
                                                    <div>
                                                        <p className="font-bold">{recognizedCard.team}</p>
                                                        {recognizedCard._differences?.team && (
                                                            <div className="text-xs text-slate-500 mt-1">
                                                                <span className="line-through">Sonnet: {recognizedCard.team}</span>
                                                                <br/>
                                                                <span className="text-purple-400">Opus: {recognizedCard._opusData.team}</span>
                                                            </div>
                                                        )}
                                                    </div>
                                                )}
                                            </div>
                                            <div>
                                                <span className="text-xs text-slate-400 flex items-center gap-1">
                                                    Subset
                                                    {recognizedCard._differences?.subset && (
                                                        <span className="text-purple-400" title="Opus updated this value">ðŸ”</span>
                                                    )}
                                                </span>
                                                {isEditing ? (
                                                    <select
                                                        value={editedCard.subset || ''}
                                                        onChange={async (e) => {
                                                            const newSubset = e.target.value;
                                                            setEditedCard({...editedCard, subset: newSubset});
                                                            
                                                            // Trigger Opus re-analysis when subset changes
                                                            if (uploadedImages && !isDeepAnalyzing) {
                                                                setTimeout(() => performDeepAnalysis(), 100);
                                                            }
                                                        }}
                                                        className="w-full bg-slate-800 border border-slate-600 rounded px-2 py-1 text-sm mt-1"
                                                    >
                                                        {/* AI-detected values first if both analyses exist */}
                                                        {recognizedCard.subset && deepAnalysis && recognizedCard._opusData && (
                                                            <>
                                                                <option value={recognizedCard.subset}>âš¡ Sonnet: {recognizedCard.subset}</option>
                                                                <option value={recognizedCard._opusData.subset}>ðŸ” Opus: {recognizedCard._opusData.subset}</option>
                                                                <option disabled>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</option>
                                                            </>
                                                        )}
                                                        {allSubsets.map(s => <option key={s} value={s}>{s}</option>)}
                                                    </select>
                                                ) : (
                                                    <div>
                                                        <p className="font-bold">{recognizedCard.subset || 'Unknown'}</p>
                                                        {recognizedCard._differences?.subset && (
                                                            <div className="text-xs text-slate-500 mt-1">
                                                                <span className="line-through">Sonnet: {recognizedCard.subset}</span>
                                                                <br/>
                                                                <span className="text-purple-400">Opus: {recognizedCard._opusData.subset}</span>
                                                            </div>
                                                        )}
                                                    </div>
                                                )}
                                            </div>
                                            <div>
                                                <span className="text-xs text-slate-400 flex items-center gap-1">
                                                    Variant
                                                    {recognizedCard._differences?.variant && (
                                                        <span className="text-purple-400" title="Opus updated this value">ðŸ”</span>
                                                    )}
                                                </span>
                                                {isEditing ? (
                                                    <select
                                                        value={editedCard.variant}
                                                        onChange={(e) => setEditedCard({...editedCard, variant: e.target.value})}
                                                        className="w-full bg-slate-800 border border-slate-600 rounded px-2 py-1 text-sm mt-1"
                                                    >
                                                        {/* AI-detected values first if both analyses exist */}
                                                        {recognizedCard.variant && deepAnalysis && recognizedCard._opusData && (
                                                            <>
                                                                <option value={recognizedCard.variant}>âš¡ Sonnet: {recognizedCard.variant}</option>
                                                                <option value={recognizedCard._opusData.variant}>ðŸ” Opus: {recognizedCard._opusData.variant}</option>
                                                                <option disabled>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</option>
                                                            </>
                                                        )}
                                                        {(() => {
                                                            const cardKey = recognizedCard?.cardNumber ? getCardKey(recognizedCard.cardNumber) : null;
                                                            const cardInventory = cardKey ? (collection[cardKey] || {}) : {};
                                                            return variants.map(v => {
                                                                const count = cardInventory[v] || 0;
                                                                return <option key={v} value={v}>{v}{count > 0 ? ` (${count})` : ''}</option>;
                                                            });
                                                        })()}
                                                    </select>
                                                ) : (
                                                    <div>
                                                        <p className="font-bold">{recognizedCard.variant}</p>
                                                        {recognizedCard._differences?.variant && (
                                                            <div className="text-xs text-slate-500 mt-1">
                                                                <span className="line-through">Sonnet: {recognizedCard.variant}</span>
                                                                <br/>
                                                                <span className="text-purple-400">Opus: {recognizedCard._opusData.variant}</span>
                                                            </div>
                                                        )}
                                                    </div>
                                                )}
                                            </div>
                                        </div>

                                        {(recognizedCard.analysis || deepAnalysis) && (
                                            <div className="mt-4 space-y-4">
                                                {/* Value Estimates Row */}
                                                {(() => {
                                                    const sonnetValues = extractValueEstimates(recognizedCard.analysis);
                                                    const opusValues = extractValueEstimates(deepAnalysis);
                                                    const valuesToShow = selectedAnalysisSource === 'opus' && opusValues ? opusValues : sonnetValues;
                                                    
                                                    return valuesToShow && (
                                                        <div className="bg-gradient-to-r from-green-900/20 to-blue-900/20 border border-green-500/30 rounded-lg p-4">
                                                            <h4 className="font-semibold text-green-400 mb-3 text-center">ðŸ’° Value Estimates (2025 Topps Chrome F1)</h4>
                                                            <div className={`grid ${isMobile ? 'grid-cols-1' : 'grid-cols-3'} gap-4`}>
                                                                <div className="text-center">
                                                                    <div className="text-xs text-slate-400 mb-1">Raw</div>
                                                                    <div className="text-xl font-bold text-green-400">{valuesToShow.raw}</div>
                                                                </div>
                                                                <div className="text-center">
                                                                    <div className="text-xs text-slate-400 mb-1">PSA 9</div>
                                                                    <div className="text-xl font-bold text-blue-400">{valuesToShow.psa9}</div>
                                                                </div>
                                                                <div className="text-center">
                                                                    <div className="text-xs text-slate-400 mb-1">PSA 10</div>
                                                                    <div className="text-xl font-bold text-purple-400">{valuesToShow.psa10}</div>
                                                                </div>
                                                            </div>
                                                            {deepAnalysis && (
                                                                <div className="mt-3 text-xs text-center text-slate-400">
                                                                    Using {selectedAnalysisSource === 'opus' ? '(Opus)' : '(Sonnet)'} analysis values
                                                                </div>
                                                            )}
                                                        </div>
                                                    );
                                                })()}
                                                
                                                {/* Analysis Source Selection (only show if both exist) */}
                                                {recognizedCard.analysis && deepAnalysis && (
                                                    <div className="flex gap-2 justify-center">
                                                        <span className="text-sm text-slate-400 self-center">Use analysis from:</span>
                                                        <button
                                                            onClick={() => setSelectedAnalysisSource('sonnet')}
                                                            className={`px-4 py-2 rounded-lg text-sm font-semibold transition-all ${
                                                                selectedAnalysisSource === 'sonnet'
                                                                    ? 'bg-blue-600 text-white shadow-lg shadow-blue-500/50'
                                                                    : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
                                                            }`}
                                                        >
                                                            âš¡ Sonnet
                                                        </button>
                                                        <button
                                                            onClick={() => setSelectedAnalysisSource('opus')}
                                                            className={`px-4 py-2 rounded-lg text-sm font-semibold transition-all ${
                                                                selectedAnalysisSource === 'opus'
                                                                    ? 'bg-blue-600 text-white shadow-lg shadow-blue-500/50'
                                                                    : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
                                                            }`}
                                                        >
                                                            ðŸ” Opus
                                                        </button>
                                                    </div>
                                                )}
                                                
                                                {/* Analysis Comparison */}
                                                <div>
                                                    <h4 className="font-semibold text-slate-200 mb-3">ðŸ“Š Analysis Comparison</h4>
                                                    <div className={`grid ${isMobile ? 'grid-cols-1' : deepAnalysis ? 'grid-cols-2' : 'grid-cols-1'} gap-4`}>
                                                        {/* Initial Analysis (Sonnet) */}
                                                        {recognizedCard.analysis && (
                                                            <div className={`p-4 rounded-lg transition-all ${
                                                                selectedAnalysisSource === 'sonnet' || !deepAnalysis
                                                                    ? 'bg-blue-900/40 border-2 border-blue-400 shadow-lg shadow-blue-500/30'
                                                                    : 'bg-blue-900/20 border border-blue-500/30'
                                                            }`}>
                                                                <div className="flex items-center justify-between mb-2">
                                                                    <h5 className="font-semibold text-blue-400">âš¡ Analysis (Sonnet)</h5>
                                                                    {selectedAnalysisSource === 'sonnet' && deepAnalysis && (
                                                                        <span className="text-xs bg-blue-600 text-white px-2 py-1 rounded-full">SELECTED</span>
                                                                    )}
                                                                </div>
                                                                <div className="text-slate-300 leading-relaxed">{formatAnalysisText(recognizedCard.analysis)}</div>
                                                            </div>
                                                        )}

                                                        {/* Deep Analysis (Opus) */}
                                                        {deepAnalysis && (
                                                            <div className={`p-4 rounded-lg transition-all ${
                                                                selectedAnalysisSource === 'opus'
                                                                    ? 'bg-blue-900/40 border-2 border-blue-400 shadow-lg shadow-blue-500/30'
                                                                    : 'bg-blue-900/20 border border-blue-500/30'
                                                            }`}>
                                                                <div className="flex items-center justify-between mb-2">
                                                                    <h5 className="font-semibold text-blue-400">ðŸ” Analysis (Opus)</h5>
                                                                    {selectedAnalysisSource === 'opus' && (
                                                                        <span className="text-xs bg-blue-600 text-white px-2 py-1 rounded-full">SELECTED</span>
                                                                    )}
                                                                </div>
                                                                <div className="text-slate-300 leading-relaxed">{formatAnalysisText(deepAnalysis)}</div>
                                                            </div>
                                                        )}
                                                    </div>

                                                    {/* Quick Grade Report */}
                                                    {recognizedCard?.gradeReport && (
                                                        <div className="mt-2 bg-blue-900/20 border border-blue-500/30 rounded p-3" data-testid="quick-grade-assessment">
                                                            <div className="flex items-center justify-between mb-3">
                                                                <button 
                                                                    onClick={(e) => {
                                                                        e.stopPropagation();
                                                                        const collapseKey = 'scanner-grade-report';
                                                                        setCollapsedSections(prev => ({...prev, [collapseKey]: !prev[collapseKey]}));
                                                                    }}
                                                                    className="font-semibold text-blue-400 text-sm flex items-center gap-1 hover:text-blue-300 transition-colors"
                                                                >
                                                                    ðŸ“Š Quick Grade Assessment
                                                                    <span className="text-xs">{collapsedSections['scanner-grade-report'] ? 'â–¼' : 'â–²'}</span>
                                                                </button>
                                                            </div>
                                                            {!collapsedSections['scanner-grade-report'] && (
                                                                <div className="text-slate-300 leading-relaxed">
                                                                    {formatQuickGradeReport(recognizedCard.gradeReport)}
                                                                </div>
                                                            )}
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                        )}

                                            </div>
                                        </div>
                                    )}
                                    </>
                                </div>
                            </div>
                        )}

                        {showSecondImagePrompt && (
                            <div className="fixed inset-0 bg-black/80 flex items-center justify-center p-4 z-50">
                                <div className="bg-slate-800 rounded-2xl p-6 max-w-md w-full">
                                    <h2 className="text-2xl font-bold mb-4">ðŸ“¸ Upload Second Image?</h2>
                                    <p className="text-slate-300 mb-4">
                                        You've uploaded <strong>1 image</strong>. For best results, upload both:
                                    </p>
                                    <ul className="text-sm text-slate-400 mb-6 space-y-2 ml-4">
                                        <li>âœ“ <strong>Front</strong> of the card</li>
                                        <li>âœ“ <strong>Back</strong> of the card (contains card number)</li>
                                    </ul>
                                    <p className="text-xs text-slate-500 mb-6 italic">
                                        The back image's card number guides AI analysis for better accuracy.
                                    </p>
                                    
                                    {/* Show the uploaded image */}
                                    {pendingImages.length > 0 && (
                                        <div className="mb-6">
                                            <p className="text-xs text-slate-400 mb-2">Current image:</p>
                                            <img 
                                                src={pendingImages[0]} 
                                                alt="Uploaded card" 
                                                className="w-full max-h-48 object-contain bg-slate-900/50 rounded-lg"
                                            />
                                        </div>
                                    )}
                                    
                                    <div className="flex flex-col gap-3">
                                        <button
                                            onClick={() => fileInputRef.current?.click()}
                                            className="w-full bg-green-600 hover:bg-green-700 px-4 py-6 rounded-lg font-semibold text-white"
                                        >
                                            ðŸ“· Add Second Image
                                        </button>
                                        <button
                                            onClick={() => {
                                                setUploadedImages(pendingImages);
                                                setPendingImages([]);
                                                setShowSecondImagePrompt(false);
                                                recognizeCard(pendingImages);
                                            }}
                                            className="w-full bg-blue-600 hover:bg-blue-700 px-4 py-3 rounded-lg font-semibold text-white"
                                        >
                                            âžœ Proceed with 1 Image
                                        </button>
                                        <button
                                            onClick={() => {
                                                setShowSecondImagePrompt(false);
                                                setPendingImages([]);
                                            }}
                                            className="w-full bg-slate-600 hover:bg-slate-700 px-4 py-3 rounded-lg font-semibold text-white"
                                        >
                                            âœ• Cancel
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Grade Camera Modal */}
                        {showGradeCamera && gradeCardContext && (
                            <GradeCameraModal
                                cardNum={gradeCardContext.cardNum}
                                variant={gradeCardContext.variant}
                                autoOpen={gradeCameraAutoOpen}
                                onAutoOpenChange={(val) => {
                                    setGradeCameraAutoOpen(val);
                                    localStorage.setItem('f1-grade-camera-auto', val.toString());
                                }}
                                onGrade={performGradeWithImages}
                                onClose={() => {
                                    setShowGradeCamera(false);
                                    setGradeCardContext(null);
                                }}
                                isMobile={isMobile}
                            />
                        )}

                        {/* Export Before Delete Modal */}
                        {showExportBeforeDelete && (
                            <div className="fixed inset-0 bg-black/80 flex items-center justify-center p-4 z-50">
                                <div className={`bg-slate-800 rounded-2xl p-6 ${isMobile ? 'w-full' : 'max-w-md w-full'}`}>
                                    <h2 className={`font-bold mb-4 ${isMobile ? 'text-xl' : 'text-2xl'} text-center`}>ðŸ“¤ Backup Your Collection?</h2>
                                    <p className="text-slate-300 mb-6 text-sm text-center">
                                        Before deleting your collection, would you like to export a backup file? You can import it later to restore your cards.
                                    </p>
                                    <div className={`flex ${isMobile ? 'flex-col' : 'gap-3'} gap-3`}>
                                        <button
                                            onClick={() => {
                                                exportCollection();
                                                setShowExportBeforeDelete(false);
                                                setShowResetConfirm(true);
                                            }}
                                            className={`flex-1 bg-blue-600 hover:bg-blue-700 rounded-lg font-semibold py-3 ${isMobile ? 'text-base' : 'px-4'}`}
                                        >
                                            ðŸ“¥ Export First
                                        </button>
                                        <button
                                            onClick={() => {
                                                setShowExportBeforeDelete(false);
                                                setShowResetConfirm(true);
                                            }}
                                            className={`flex-1 bg-slate-600 hover:bg-slate-700 rounded-lg font-semibold py-3 ${isMobile ? 'text-base' : 'px-4'}`}
                                        >
                                            Skip Export
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {showResetConfirm && (
                            <div className="fixed inset-0 bg-black/80 flex items-center justify-center p-4 z-50">
                                <div className={`bg-slate-800 rounded-2xl p-6 ${isMobile ? 'w-full' : 'max-w-md w-full'}`}>
                                    <h2 className={`font-bold mb-4 text-red-400 text-center ${isMobile ? 'text-xl' : 'text-2xl'}`}>âš ï¸ Delete Collection?</h2>
                                    <p className="text-slate-300 mb-6 text-sm text-center">
                                        This will PERMANENTLY DELETE your entire collection. This action CANNOT be undone!
                                    </p>
                                    <div className={`flex ${isMobile ? 'flex-col' : 'gap-3'} gap-3`}>
                                        <button
                                            onClick={() => setShowResetConfirm(false)}
                                            className={`flex-1 bg-slate-600 hover:bg-slate-700 rounded-lg font-semibold py-3 ${isMobile ? 'text-base' : 'px-4'}`}
                                        >
                                            Cancel
                                        </button>
                                        <button
                                            onClick={resetCollection}
                                            className={`flex-1 bg-red-600 hover:bg-red-700 rounded-lg font-semibold py-3 ${isMobile ? 'text-base' : 'px-4'}`}
                                        >
                                            Yes, Delete
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Manual Card Addition Modal */}
                        {showAddCardManual && (
                            <div className="fixed inset-0 bg-black/80 flex items-center justify-center p-4 z-50"
                                onClick={() => {
                                    setShowAddCardManual(false);
                                    setManualCardData({ cardNumber: '', variant: 'Base', serialNumber: '', cardTitle: '', driverName: '', value: '' });
                                }}>
                                <div className={`bg-slate-800 rounded-2xl p-6 ${isMobile ? 'w-full max-h-[95vh]' : 'max-w-2xl w-full max-h-[90vh]'} overflow-y-auto scrollbar-hide`} onClick={(e) => e.stopPropagation()}>
                                    <h2 className="text-2xl font-bold mb-2">âž• Add a Card</h2>
                                    <p className="text-slate-300 mb-6 text-sm">Enter card details below. Serial number is optional.</p>
                                    
                                    <div className="space-y-4">
                                        {/* Card Number */}
                                        <div>
                                            <label className="text-sm font-semibold text-slate-300 block mb-2">Card Number *</label>
                                            <input
                                                type="text"
                                                value={manualCardData.cardNumber}
                                                onChange={(e) => setManualCardData({...manualCardData, cardNumber: e.target.value})}
                                                placeholder="e.g., 1, 5, 25"
                                                className="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg text-sm focus:border-blue-500 focus:outline-none text-white"
                                            />
                                        </div>
                                        
                                        {/* Variant Selector */}
                                        <div>
                                            <label className="text-sm font-semibold text-slate-300 block mb-2">Variant</label>
                                            <select
                                                value={manualCardData.variant}
                                                onChange={(e) => setManualCardData({...manualCardData, variant: e.target.value})}
                                                className="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg text-sm focus:border-blue-500 focus:outline-none text-white"
                                            >
                                                {(() => {
                                                    const cardKey = manualCardData.cardNumber ? getCardKey(manualCardData.cardNumber) : null;
                                                    const cardInventory = cardKey ? (collection[cardKey] || {}) : {};
                                                    return OFFICIAL_VARIANTS.map(variant => {
                                                        const count = cardInventory[variant] || 0;
                                                        return (
                                                            <option key={variant} value={variant}>{variant}{count > 0 ? ` (${count})` : ''}</option>
                                                        );
                                                    });
                                                })()}
                                            </select>
                                        </div>

                                        {/* Serial Number */}
                                        <div>
                                            <label className="text-sm font-semibold text-slate-300 block mb-2">Serial Number (Optional)</label>
                                            <input
                                                type="text"
                                                value={manualCardData.serialNumber}
                                                onChange={(e) => setManualCardData({...manualCardData, serialNumber: e.target.value})}
                                                placeholder="e.g., 63/250, /99, N/A"
                                                className="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg text-sm focus:border-blue-500 focus:outline-none text-white"
                                            />
                                            <p className="text-xs text-slate-500 mt-1">The serial number helps identify the correct variant.</p>
                                        </div>
                                        
                                        {/* Driver/Card Title Section */}
                                        {loadingCardDetails && (
                                            <div className="bg-blue-900/20 border border-blue-500/30 rounded p-3">
                                                <p className="text-xs text-blue-300">
                                                    ðŸ” Looking up card details...
                                                </p>
                                            </div>
                                        )}
                                        
                                        {/* Driver Name */}
                                        <div>
                                            <label className="text-sm font-semibold text-slate-300 block mb-2">Driver Name (Optional)</label>
                                            <input
                                                type="text"
                                                value={manualCardData.driverName}
                                                onChange={(e) => setManualCardData({...manualCardData, driverName: e.target.value})}
                                                placeholder="e.g., Max Verstappen, Lewis Hamilton"
                                                className="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg text-sm focus:border-blue-500 focus:outline-none text-white"
                                            />
                                        </div>
                                        
                                        {/* Card Title */}
                                        <div>
                                            <label className="text-sm font-semibold text-slate-300 block mb-2">Card Title (Optional)</label>
                                            <input
                                                type="text"
                                                value={manualCardData.cardTitle}
                                                onChange={(e) => setManualCardData({...manualCardData, cardTitle: e.target.value})}
                                                placeholder="e.g., F1 Drivers, F2 Drivers, F1 Cars"
                                                className="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg text-sm focus:border-blue-500 focus:outline-none text-white"
                                            />
                                        </div>
                                        
                                        {/* Card Value */}
                                        <div>
                                            <label className="text-sm font-semibold text-slate-300 block mb-2">Estimated Value (Optional)</label>
                                            <input
                                                type="text"
                                                value={manualCardData.value}
                                                onChange={(e) => setManualCardData({...manualCardData, value: e.target.value})}
                                                placeholder="e.g., $2-5, $10-15"
                                                className="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg text-sm focus:border-blue-500 focus:outline-none text-white"
                                            />
                                            <p className="text-xs text-slate-500 mt-1">Market value estimate for reference.</p>
                                        </div>
                                        
                                        {/* Info box */}
                                        <div className="bg-blue-900/20 border border-blue-500/30 rounded p-3 mt-4">
                                            <p className="text-xs text-blue-300">
                                                <strong>â„¹ï¸ Tip:</strong> If you have the physical card, take a photo of the back to get the exact serial number.
                                            </p>
                                        </div>
                                    </div>
                                    
                                    {/* Action Buttons */}
                                    <div className="flex gap-3 mt-6">
                                        <button
                                            onClick={() => {
                                                if (manualCardData.cardNumber.trim()) {
                                                    addCard(manualCardData.cardNumber, manualCardData.variant, null, null);
                                                    setShowAddCardManual(false);
                                                    setManualCardData({ cardNumber: '', variant: 'Base', serialNumber: '', cardTitle: '', driverName: '', value: '' });
                                                } else {
                                                    alert('Please enter a card number');
                                                }
                                            }}
                                            className="flex-1 bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded-lg font-semibold text-sm transition-all"
                                        >
                                            âœ“ Add Card
                                        </button>
                                        <button
                                            onClick={() => {
                                                setShowAddCardManual(false);
                                                setManualCardData({ cardNumber: '', variant: 'Base', serialNumber: '', cardTitle: '', driverName: '', value: '' });
                                            }}
                                            className="flex-1 bg-slate-600 hover:bg-slate-700 text-white py-2 px-4 rounded-lg font-semibold text-sm transition-all"
                                        >
                                            âœ• Cancel
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Variant Selection Modal */}
                        {variantValidationModal && (
                            <div className="fixed inset-0 bg-black/80 flex items-center justify-center p-4 z-50">
                                <div className={`bg-slate-800 rounded-2xl p-6 ${isMobile ? 'w-full max-h-[90vh]' : 'max-w-md w-full max-h-96'} overflow-y-auto`}>
                                    <h2 className="text-2xl font-bold mb-2">âš ï¸ Confirm Card Variant</h2>
                                    <p className="text-slate-300 mb-4 text-sm">
                                        The AI detected "<span className="font-semibold text-blue-300">{variantValidationModal.aiVariant}</span>" but this doesn't match our official variants list.
                                    </p>
                                    <p className="text-slate-400 mb-4 text-sm">
                                        Please select the correct variant for Card #{variantValidationModal.cardNum}:
                                    </p>
                                    <div className="space-y-3 mb-4 max-h-96 overflow-y-auto">
                                        {/* Standard */}
                                        <div>
                                            <p className="text-xs font-bold text-slate-400 px-3 py-2 uppercase">Standard</p>
                                            {['Base', 'Refractor'].map(variant => (
                                                <button
                                                    key={variant}
                                                    onClick={() => {
                                                        addCardWithVariant(
                                                            variantValidationModal.cardNum,
                                                            variant,
                                                            variantValidationModal.pendingAnalysis
                                                        );
                                                    }}
                                                    className="w-full text-left p-3 rounded-lg bg-slate-700 hover:bg-blue-600 transition-colors mb-1"
                                                >
                                                    {variant}
                                                </button>
                                            ))}
                                        </div>

                                        {/* Numbered Color Refractors */}
                                        <div>
                                            <p className="text-xs font-bold text-slate-400 px-3 py-2 uppercase">Numbered Refractors</p>
                                            {['Teal Refractor /299', 'Pink Refractor /250', 'Aqua Refractor /199', 'Blue Refractor /150', 'Green Refractor /99', 'F1 75th Anniversary Refractor /75', 'Gold Refractor /50', 'Orange Refractor /25', 'Black Refractor /10', 'Red Refractor /5'].map(variant => (
                                                <button
                                                    key={variant}
                                                    onClick={() => {
                                                        addCardWithVariant(
                                                            variantValidationModal.cardNum,
                                                            variant,
                                                            variantValidationModal.pendingAnalysis
                                                        );
                                                    }}
                                                    className="w-full text-left p-3 rounded-lg bg-slate-700 hover:bg-blue-600 transition-colors mb-1"
                                                >
                                                    {variant}
                                                </button>
                                            ))}
                                        </div>

                                        {/* Checker Flag Parallels */}
                                        <div>
                                            <p className="text-xs font-bold text-slate-400 px-3 py-2 uppercase">Checker Flag Parallels</p>
                                            {['Checker Flag', 'Pink Checker Flag /250', 'Aqua Checker Flag /199', 'Blue Checker Flag /150', 'Green Checker Flag /99', 'Gold Checker Flag /50', 'Orange Checker Flag /25', 'Black Checker Flag /10', 'Red Checker Flag /5'].map(variant => (
                                                <button
                                                    key={variant}
                                                    onClick={() => {
                                                        addCardWithVariant(
                                                            variantValidationModal.cardNum,
                                                            variant,
                                                            variantValidationModal.pendingAnalysis
                                                        );
                                                    }}
                                                    className="w-full text-left p-3 rounded-lg bg-slate-700 hover:bg-blue-600 transition-colors mb-1"
                                                >
                                                    {variant}
                                                </button>
                                            ))}
                                        </div>

                                        {/* RayWave Parallels */}
                                        <div>
                                            <p className="text-xs font-bold text-slate-400 px-3 py-2 uppercase">RayWave Parallels</p>
                                            {['B&W RayWave', 'Pink RayWave /250', 'Aqua RayWave /199', 'Blue RayWave /150', 'Forest Green RayWave /140', 'Green RayWave /99', 'Gold RayWave /50', 'Orange RayWave /25', 'Black RayWave /10', 'Red RayWave /5'].map(variant => (
                                                <button
                                                    key={variant}
                                                    onClick={() => {
                                                        addCardWithVariant(
                                                            variantValidationModal.cardNum,
                                                            variant,
                                                            variantValidationModal.pendingAnalysis
                                                        );
                                                    }}
                                                    className="w-full text-left p-3 rounded-lg bg-slate-700 hover:bg-blue-600 transition-colors mb-1"
                                                >
                                                    {variant}
                                                </button>
                                            ))}
                                        </div>

                                        {/* Lazer & Special Types */}
                                        <div>
                                            <p className="text-xs font-bold text-slate-400 px-3 py-2 uppercase">Lazer & Special</p>
                                            {['B&W Lazer', 'SuperFractor 1/1', 'Logofractor', 'Sapphire Edition', 'Padparadscha Sapphire 1/1'].map(variant => (
                                                <button
                                                    key={variant}
                                                    onClick={() => {
                                                        addCardWithVariant(
                                                            variantValidationModal.cardNum,
                                                            variant,
                                                            variantValidationModal.pendingAnalysis
                                                        );
                                                    }}
                                                    className="w-full text-left p-3 rounded-lg bg-slate-700 hover:bg-blue-600 transition-colors mb-1"
                                                >
                                                    {variant}
                                                </button>
                                            ))}
                                        </div>

                                        {/* Printing Plates */}
                                        <div>
                                            <p className="text-xs font-bold text-slate-400 px-3 py-2 uppercase">Printing Plates</p>
                                            {['Printing Plate Cyan 1/1', 'Printing Plate Magenta 1/1', 'Printing Plate Yellow 1/1', 'Printing Plate Black 1/1'].map(variant => (
                                                <button
                                                    key={variant}
                                                    onClick={() => {
                                                        addCardWithVariant(
                                                            variantValidationModal.cardNum,
                                                            variant,
                                                            variantValidationModal.pendingAnalysis
                                                        );
                                                    }}
                                                    className="w-full text-left p-3 rounded-lg bg-slate-700 hover:bg-blue-600 transition-colors mb-1"
                                                >
                                                    {variant}
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                    <button
                                        onClick={() => setVariantValidationModal(null)}
                                        className="w-full bg-slate-600 hover:bg-slate-700 px-4 py-2 rounded-lg font-semibold"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        )}
                        {showImageViewer && uploadedImages && uploadedImages.length > 0 && (
                            <div className="fixed inset-0 bg-black/95 flex items-center justify-center z-50">
                                {/* Top Controls */}
                                <div className="absolute top-4 right-4 flex gap-2 z-10">
                                    <button
                                        onClick={() => setImageViewerZoom(Math.max(0.5, imageViewerZoom - 0.25))}
                                        className="bg-slate-800 hover:bg-slate-700 text-white rounded-lg font-semibold px-4 py-2"
                                        title="Zoom Out"
                                    >
                                        âˆ’
                                    </button>
                                    <button
                                        onClick={() => setImageViewerZoom(1)}
                                        className="bg-slate-800 hover:bg-slate-700 text-white rounded-lg font-semibold px-4 py-2"
                                        title="Reset Zoom"
                                    >
                                        {Math.round(imageViewerZoom * 100)}%
                                    </button>
                                    <button
                                        onClick={() => setImageViewerZoom(Math.min(5, imageViewerZoom + 0.25))}
                                        className="bg-slate-800 hover:bg-slate-700 text-white rounded-lg font-semibold px-4 py-2"
                                        title="Zoom In"
                                    >
                                        +
                                    </button>
                                    <button
                                        onClick={() => {
                                            setShowImageViewer(false);
                                            setImageViewerZoom(1);
                                            setImageViewerPosition({ x: 0, y: 0 });
                                            setCurrentImageIndex(0);
                                        }}
                                        className="bg-red-600 hover:bg-red-700 text-white rounded-lg font-semibold px-4 py-2"
                                        title="Close"
                                    >
                                        âœ•
                                    </button>
                                </div>

                                {/* Image Counter */}
                                {uploadedImages.length > 1 && (
                                    <div className="absolute top-4 left-4 bg-slate-800/90 text-white px-4 py-2 rounded-lg text-sm font-semibold">
                                        {uploadedImages.length === 2 ? (currentImageIndex === 0 ? 'ðŸ“· Front' : 'ðŸ“· Back') : `ðŸ“· Image ${currentImageIndex + 1}/${uploadedImages.length}`}
                                    </div>
                                )}

                                {/* Main Image Container */}
                                <div 
                                    className="w-full h-full flex items-center justify-center overflow-hidden p-8 select-none"
                                    onWheel={(e) => {
                                        e.preventDefault();
                                        const delta = e.deltaY > 0 ? -0.1 : 0.1;
                                        setImageViewerZoom(Math.max(0.5, Math.min(5, imageViewerZoom + delta)));
                                    }}
                                    onTouchStart={(e) => {
                                        if (e.touches.length === 2) {
                                            const touch1 = e.touches[0];
                                            const touch2 = e.touches[1];
                                            const distance = Math.hypot(
                                                touch2.clientX - touch1.clientX,
                                                touch2.clientY - touch1.clientY
                                            );
                                            setImageViewerTouchStart({ x: 0, y: 0, distance });
                                        } else if (e.touches.length === 1) {
                                            setImageViewerTouchStart({ 
                                                x: e.touches[0].clientX, 
                                                y: e.touches[0].clientY, 
                                                distance: 0 
                                            });
                                        }
                                    }}
                                    onTouchMove={(e) => {
                                        if (e.touches.length === 2) {
                                            const touch1 = e.touches[0];
                                            const touch2 = e.touches[1];
                                            const distance = Math.hypot(
                                                touch2.clientX - touch1.clientX,
                                                touch2.clientY - touch1.clientY
                                            );
                                            
                                            if (imageViewerTouchStart.distance > 0) {
                                                const scale = distance / imageViewerTouchStart.distance;
                                                const newZoom = Math.max(0.5, Math.min(5, imageViewerZoom * scale));
                                                setImageViewerZoom(newZoom);
                                            }
                                            setImageViewerTouchStart({ ...imageViewerTouchStart, distance });
                                        } else if (e.touches.length === 1 && imageViewerZoom > 1) {
                                            const deltaX = e.touches[0].clientX - imageViewerTouchStart.x;
                                            const deltaY = e.touches[0].clientY - imageViewerTouchStart.y;
                                            setImageViewerPosition({
                                                x: imageViewerPosition.x + deltaX,
                                                y: imageViewerPosition.y + deltaY
                                            });
                                            setImageViewerTouchStart({ 
                                                x: e.touches[0].clientX, 
                                                y: e.touches[0].clientY, 
                                                distance: 0 
                                            });
                                        }
                                    }}
                                >
                                    <img 
                                        src={uploadedImages[currentImageIndex]} 
                                        alt={`Card image ${currentImageIndex + 1}`}
                                        style={{
                                            transform: `scale(${imageViewerZoom}) translate(${imageViewerPosition.x}px, ${imageViewerPosition.y}px)`,
                                            maxWidth: '90vw',
                                            maxHeight: '90vh',
                                            objectFit: 'contain',
                                            transition: imageViewerZoom === 1 ? 'transform 0.2s ease-out' : 'none'
                                        }}
                                        draggable={false}
                                    />
                                </div>

                                {/* Navigation Buttons - Show only if multiple images */}
                                {uploadedImages.length > 1 && (
                                    <>
                                        <button
                                            onClick={() => {
                                                setCurrentImageIndex((prev) => (prev === 0 ? uploadedImages.length - 1 : prev - 1));
                                                setImageViewerZoom(1);
                                                setImageViewerPosition({ x: 0, y: 0 });
                                            }}
                                            className="absolute left-4 top-1/2 -translate-y-1/2 bg-slate-800/80 hover:bg-slate-700 text-white rounded-lg font-bold px-4 py-3 text-2xl transition-all"
                                            title="Previous image"
                                        >
                                            â€¹
                                        </button>
                                        <button
                                            onClick={() => {
                                                setCurrentImageIndex((prev) => (prev === uploadedImages.length - 1 ? 0 : prev + 1));
                                                setImageViewerZoom(1);
                                                setImageViewerPosition({ x: 0, y: 0 });
                                            }}
                                            className="absolute right-4 top-1/2 -translate-y-1/2 bg-slate-800/80 hover:bg-slate-700 text-white rounded-lg font-bold px-4 py-3 text-2xl transition-all"
                                            title="Next image"
                                        >
                                            â€º
                                        </button>
                                    </>
                                )}

                                {/* Instructions */}
                                <div className="absolute bottom-4 left-1/2 -translate-x-1/2 bg-slate-800/90 text-white px-6 py-3 rounded-lg text-sm">
                                    <p>ðŸ“± Pinch to zoom â€¢ ðŸ‘† Drag to pan â€¢ ðŸ–±ï¸ Scroll to zoom â€¢ Buttons to zoom</p>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Toast notification â€” non-blocking, auto-dismissing */}
                    {toastMessage && (
                        <div
                            className="fixed bottom-20 left-1/2 -translate-x-1/2 z-[9999] max-w-md w-[90vw] bg-slate-800 border border-slate-600 text-white px-4 py-3 rounded-xl shadow-2xl text-sm animate-pulse cursor-pointer"
                            onClick={() => setToastMessage(null)}
                        >
                            {toastMessage}
                        </div>
                    )}
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
